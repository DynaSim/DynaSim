<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of nDDict</title>
  <meta name="keywords" content="nDDict">
  <meta name="description" content="">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- ../../menu.html functions_xPlt --><!-- ../menu.html classes --><!-- menu.html @nDDict -->
<h1>nDDict
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong></strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>This is a script file. </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"></pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="nDDict.html" class="code" title="">nDDict</a>	</li><li><a href="../../../functions_xPlt/classes/nDDictAxis.html" class="code" title="">nDDictAxis</a>	</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../functions/ds.specDiff.html" class="code" title="function [pop_diff,conn_diff] = ds.specDiff(spec1,spec2,verbose)">ds.specDiff</a>	ds.specDiff - Scans two DynaSim specs for differences</li><li><a href="nDDict.html" class="code" title="">nDDict</a>	</li><li><a href="../../../functions_xPlt/classes/@xPlt/xPlt.html" class="code" title="">xPlt</a>	</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function obj = nDDict(data,axis,meta)</a></li><li><a href="#_sub2" class="code">function [obj] = reset(obj)</a></li><li><a href="#_sub3" class="code">function [obj2, ro] = subset(obj,varargin)</a></li><li><a href="#_sub4" class="code">function obj = importAxisNames(obj,ax_names)</a></li><li><a href="#_sub5" class="code">function obj = importMeta(obj,meta_struct)</a></li><li><a href="#_sub6" class="code">function [selection_out, startIndex] = findaxis(obj,str)</a></li><li><a href="#_sub7" class="code">function obj = mergeDims(obj,dims2pack)</a></li><li><a href="#_sub8" class="code">function obj = packDim(obj,dim_src,dim_target)</a></li><li><a href="#_sub9" class="code">function out = getaxisinfo(obj)</a></li><li><a href="#_sub10" class="code">function obj = fixAxes(obj)</a></li><li><a href="#_sub11" class="code">function checkDims(obj)</a></li><li><a href="#_sub12" class="code">function A = isempty(obj)</a></li><li><a href="#_sub13" class="code">function varargout = size(obj,varargin)</a></li><li><a href="#_sub14" class="code">function Nd = ndims(obj)</a></li><li><a href="#_sub15" class="code">function obj = permute(obj,order)</a></li><li><a href="#_sub16" class="code">function obj = transpose(obj)</a></li><li><a href="#_sub17" class="code">function obj = squeeze(obj)</a></li><li><a href="#_sub18" class="code">function output = inheritObj(output,input)</a></li><li><a href="#_sub19" class="code">function obj = setAxisDefaultNames(obj,dim)</a></li><li><a href="#_sub20" class="code">function [selection_out, startIndex] = regex_lookup(vals, selection)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 
0002 classdef <a href="nDDict.html" class="code" title="">nDDict</a>
0003 
0004     properties
0005         data               <span class="comment">% Storing the actual data (multi-dimensional matrix or cell array)</span>
0006         axis = <a href="../../../functions_xPlt/classes/nDDictAxis.html" class="code" title="">nDDictAxis</a>  <span class="comment">% 1xNdims - array of nDDictAxis classes for each axis. Ndims = ndims(data)</span>
0007         meta = struct;     <span class="comment">% Metadata about stuff that's stored in data</span>
0008     <span class="keyword">end</span>
0009     
0010     
0011     methods
0012 
0013         <a name="_sub0" href="#_subfunctions" class="code">function obj = nDDict(data,axis,meta)</a>
0014             <span class="keyword">if</span> exist(<span class="string">'data'</span>,<span class="string">'var'</span>)
0015                 obj.data = data;
0016             <span class="keyword">end</span>
0017             
0018             <span class="keyword">if</span> exist(<span class="string">'axis'</span>,<span class="string">'var'</span>)
0019                 obj.axis = axis;
0020             <span class="keyword">end</span>
0021             
0022             <span class="keyword">if</span> exist(<span class="string">'meta'</span>,<span class="string">'var'</span>)
0023                 obj.meta = meta;
0024             <span class="keyword">end</span>
0025             
0026         <span class="keyword">end</span>
0027         
0028         <a name="_sub1" href="#_subfunctions" class="code">function [obj] = reset(obj)</a>
0029             obj.data = [];
0030             obj.axis = <a href="../../../functions_xPlt/classes/nDDictAxis.html" class="code" title="">nDDictAxis</a>;
0031             obj.meta = struct;
0032         <span class="keyword">end</span>
0033 
0034         <a name="_sub2" href="#_subfunctions" class="code">function [obj2, ro] = subset(obj,varargin)</a>
0035             <span class="comment">% Define variables and check that all dimensions are consistent</span>
0036             <span class="comment">% ro - if regular expressions are used, returns the index</span>
0037             <span class="comment">% values discovered by the regular expression.</span>
0038             
0039             <span class="comment">% Verify that size of obj is correct</span>
0040             <a href="#_sub11" class="code" title="subfunction checkDims(obj)">checkDims</a>(obj);
0041             
0042             <span class="comment">% Validate that &quot;selection&quot; is the right size</span>
0043             selection = varargin(:);
0044             Na = length(obj.axis);
0045             Nd = <a href="#_sub14" class="code" title="subfunction Nd = ndims(obj)">ndims</a>(obj.data);
0046             
0047             <span class="comment">% Fill out selection with empties if too short. For example, say</span>
0048             <span class="comment">% size(obj.data) is MxNx1x1. The user might enter a selection with</span>
0049             <span class="comment">% length(selection) = 2, such as selection = {[A],[B]}. In this</span>
0050             <span class="comment">% case, we convert it from to selection = {[A],[B],[],[]}.</span>
0051             Ns = length(selection);
0052             <span class="keyword">if</span> Ns &lt; Na &amp;&amp; Ns &gt;= Nd
0053                 selection2 = repmat({[]},1,Na);
0054                 selection2(1:Ns) = selection;
0055                 selection = selection2;
0056                 clear selection2
0057             <span class="keyword">end</span>
0058             
0059             <span class="comment">% If Ns is still wrong dimensions, return error</span>
0060             Ns = length(selection);
0061             <span class="keyword">if</span> Ns ~= Na
0062                 error(<span class="string">'Number of inputs must match dimensionality of nDDict.data'</span>);
0063             <span class="keyword">end</span>
0064             
0065             <span class="comment">% Convert selection to index if using regular expressions</span>
0066             ro = {};
0067             <span class="keyword">for</span> i = 1:Ns
0068                 <span class="keyword">if</span> ischar(selection{i})
0069                     ro{i}(1,:) = obj.axis(i).values;
0070                     [selection{i} ro{i}(2,:)] = <a href="#_sub20" class="code" title="subfunction [selection_out, startIndex] = regex_lookup(vals, selection)">regex_lookup</a>(obj.axis(i).values, selection{i});
0071                     
0072                 <span class="keyword">end</span>
0073             <span class="keyword">end</span>
0074             
0075             <span class="comment">% Initialize</span>
0076             sz = <a href="#_sub13" class="code" title="subfunction varargout = size(obj,varargin)">size</a>(obj);
0077             obj2 = obj;             <span class="comment">% Create new class of same type as original</span>
0078             obj2 = obj2.reset;
0079             obj2.meta = obj.meta;
0080             
0081             <span class="comment">% First update each axis with the corresponding selection and</span>
0082             <span class="comment">% convert empty cells to code for full range.</span>
0083             <span class="keyword">for</span> i = 1:Ns
0084 
0085                 <span class="keyword">if</span> <a href="#_sub12" class="code" title="subfunction A = isempty(obj)">isempty</a>(selection{i})
0086                     selection{i} = 1:sz(i);
0087                 <span class="keyword">end</span>
0088                 
0089                 obj2.axis(i) = obj.axis(i);       <span class="comment">% Import axis information</span>
0090                 obj2.axis(i).values = obj.axis(i).values(selection{i});   <span class="comment">% Overwrite values field; leave everything else the same.</span>
0091             <span class="keyword">end</span>
0092             
0093             <span class="comment">% Update the data</span>
0094             obj2.data = obj.data(selection{:});
0095             
0096             <span class="comment">% Corrects number of axes. The above code automatically</span>
0097             <span class="comment">% converts obj.data from MxNx1x1 to MxN, whereas axis will stay</span>
0098             <span class="comment">% as MxNx1x1 (e.g. length of 4). Thus, fixAxes corrects this.</span>
0099             <span class="comment">% This should no longer be necessary!!!</span>
0100             <span class="comment">% obj2 = fixAxes(obj2);</span>
0101             
0102         <span class="keyword">end</span>
0103         
0104         <a name="_sub3" href="#_subfunctions" class="code">function obj = importAxisNames(obj,ax_names)</a>
0105             Nd = <a href="#_sub14" class="code" title="subfunction Nd = ndims(obj)">ndims</a>(obj.data);
0106             <span class="keyword">if</span> nargin &lt; 2
0107                 ax_names = cellfun(@num2str,num2cell(1:5),<span class="string">'UniformOutput'</span>,0);
0108             <span class="keyword">end</span>
0109             
0110             <span class="keyword">if</span> length(ax_names) ~= Nd
0111                 error(<span class="string">'Mismatch between number of axis names supplied and number of dimensions in dataset'</span>); <span class="keyword">end</span>
0112 
0113             <span class="keyword">for</span> i = 1:<a href="#_sub14" class="code" title="subfunction Nd = ndims(obj)">ndims</a>(obj.data)
0114                 obj.axis(i).name = ax_names{i};
0115             <span class="keyword">end</span>
0116         <span class="keyword">end</span>
0117         
0118         <a name="_sub4" href="#_subfunctions" class="code">function obj = importMeta(obj,meta_struct)</a>
0119             obj.meta = meta_struct;
0120         <span class="keyword">end</span>
0121         
0122         <a name="_sub5" href="#_subfunctions" class="code">function [selection_out, startIndex] = findaxis(obj,str)</a>
0123             <span class="comment">% Returns the index of the axis with name matching str</span>
0124             allnames = {obj.axis.name};
0125             [selection_out, startIndex] = <a href="#_sub20" class="code" title="subfunction [selection_out, startIndex] = regex_lookup(vals, selection)">regex_lookup</a>(allnames, str);
0126         <span class="keyword">end</span>
0127         
0128         <a name="_sub6" href="#_subfunctions" class="code">function obj = mergeDims(obj,dims2pack)</a>
0129             
0130             obj.checkDims;
0131             Nd2p = length(dims2pack);
0132             sz = <a href="#_sub13" class="code" title="subfunction varargout = size(obj,varargin)">size</a>(obj.data);
0133             Nmerged = prod(sz(dims2pack));       <span class="comment">% Final number entries in the merged dimension</span>
0134             
0135             
0136             <span class="comment">% % First, do axis names</span>
0137             <span class="comment">% Get cell array of all linearized axis values.</span>
0138             inds = 1:Nmerged;
0139             [subs{1:Nd2p}] = ind2sub(sz(dims2pack),inds);
0140             temp = cell(1,Nd2p);
0141             <span class="keyword">for</span> i = 1:Nd2p
0142                 <span class="keyword">for</span> j = 1:Nmerged
0143                     ax = obj.axis(dims2pack(i));
0144                     currval = ax.values(subs{i}(j));
0145                     temp{i}(j) = currval;
0146                 <span class="keyword">end</span>
0147             <span class="keyword">end</span>
0148             
0149             <span class="comment">% Compress these into a single string to be used as new value name</span>
0150             tempstr = {};
0151             <span class="keyword">for</span> i = 1:Nd2p
0152                 <span class="keyword">for</span> j = 1:Nmerged
0153                     <span class="keyword">if</span> iscell(temp{i}); currval = temp{i}{j};
0154                     <span class="keyword">else</span>
0155                         currval = num2str(temp{i}(j));  <span class="comment">% If it's not a string, convert it to one.</span>
0156                     <span class="keyword">end</span>
0157                     <span class="keyword">if</span> i == 1; tempstr{j} = currval;
0158                     <span class="keyword">else</span> tempstr{j} = [tempstr{j} <span class="string">'_'</span> currval];
0159                     <span class="keyword">end</span>
0160                 <span class="keyword">end</span>
0161             <span class="keyword">end</span>
0162             
0163             <span class="comment">% Finally drop this into the values entry for the new &quot;merged&quot;</span>
0164             <span class="comment">% axis</span>
0165             obj.axis(dims2pack(1)).values = tempstr;
0166             obj.axis(dims2pack(1)).astruct.premerged_values = temp;
0167             
0168             
0169             <span class="comment">% Give it a new axis name, reflecting the merger of all the</span>
0170             <span class="comment">% others</span>
0171             allnames = {obj.axis(dims2pack).name};
0172             allnames = cat(1,allnames(:)',repmat({<span class="string">'_'</span>},1,length(allnames)));
0173             obj.axis(dims2pack(1)).name = strcat(allnames{1:end-1});
0174             
0175             <span class="comment">% Clear the remaining axes names</span>
0176             <span class="keyword">for</span> i = 2:Nd2p
0177                 obj.axis(dims2pack(i)).name = [<span class="string">'Dim '</span> num2str(dims2pack(i))];
0178                 obj.axis(dims2pack(i)).values = 1;
0179             <span class="keyword">end</span>
0180 
0181 
0182             <span class="comment">% % Now, work on obj.data</span>
0183             dat = obj.data;
0184             obj.data = [];       <span class="comment">% Clear obj.data for now, to save memory.</span>
0185             
0186             <span class="comment">% Figure out which dimensions were *NOT* Targeted for the merge</span>
0187             Nd = <a href="#_sub14" class="code" title="subfunction Nd = ndims(obj)">ndims</a>(dat);
0188             alldims = 1:Nd;
0189             ind_chosen = false(<a href="#_sub13" class="code" title="subfunction varargout = size(obj,varargin)">size</a>(alldims));
0190             <span class="keyword">for</span> i = 1:length(dims2pack)
0191                 ind_chosen = ind_chosen | alldims == dims2pack(i);
0192             <span class="keyword">end</span>
0193             ind_unchosen = ~ind_chosen;
0194             dims_remaining = find(ind_unchosen);
0195             
0196             <span class="comment">% Bring the dims to be merged to the front</span>
0197             dat = <a href="#_sub15" class="code" title="subfunction obj = permute(obj,order)">permute</a>(dat,[dims2pack,dims_remaining]);
0198             
0199             <span class="comment">% REshape these into a single dim</span>
0200             sz = <a href="#_sub13" class="code" title="subfunction varargout = size(obj,varargin)">size</a>(dat);
0201             dat = reshape(dat,[ prod(sz(1:Nd2p)), ones(1,Nd2p-1), sz(Nd2p+1:end) ]);
0202             
0203             <span class="comment">% Undo the earlier permute, and put back into obj.data</span>
0204             dat = ipermute(dat,[dims2pack,dims_remaining]);
0205             obj.data = dat;
0206         <span class="keyword">end</span>
0207         
0208         <a name="_sub7" href="#_subfunctions" class="code">function obj = packDim(obj,dim_src,dim_target)</a>
0209             
0210             <span class="keyword">if</span> nargin &lt; 3; dim_target = dim_src; <span class="keyword">end</span>
0211             <a href="#_sub11" class="code" title="subfunction checkDims(obj)">checkDims</a>(obj);
0212             
0213             <span class="comment">% Make sure that obj.data is a cell array</span>
0214             <span class="keyword">if</span> ~iscell(obj.data); error(<span class="string">'nDDict.data must be a cell array.'</span>); <span class="keyword">end</span>
0215             
0216             <span class="comment">% Make sure that obj.data is a matrix</span>
0217             temp = cellfun(@ismatrix,obj.data);
0218             <span class="keyword">if</span> any(temp(:) ~= 1); error(<span class="string">'nDDict.data must contain only matrices'</span>); <span class="keyword">end</span>
0219             <span class="comment">% % To do: implement this so it works with cell arrays and nDDict</span>
0220             <span class="comment">% classes in the future too</span>
0221             
0222             <span class="comment">% Make sure target dimension in nDDict.data is a singleton</span>
0223             temp = cellfun(@(x) <a href="#_sub13" class="code" title="subfunction varargout = size(obj,varargin)">size</a>(x,dim_target),obj.data);
0224             <span class="keyword">if</span> any(temp(:) ~= 1); error(<span class="string">'Target dimension in nDDict.data needs to be size 1. Try reshaping contents of nDDict.data or choosing a different target dimension.'</span>); <span class="keyword">end</span>
0225             clear sz_targets
0226             
0227             <span class="comment">% Bring chosen dimension to the front. Thus, we will be</span>
0228             <span class="comment">% merging along rows.</span>
0229             Nd = <a href="#_sub14" class="code" title="subfunction Nd = ndims(obj)">ndims</a>(obj.data);
0230             obj.data = <a href="#_sub15" class="code" title="subfunction obj = permute(obj,order)">permute</a>(obj.data,[dim_src, 1:dim_src-1, dim_src+1:Nd]);
0231             
0232             <span class="comment">% Temporarily linearize all other dimensions.</span>
0233             sz0 = <a href="#_sub13" class="code" title="subfunction varargout = size(obj,varargin)">size</a>(obj.data);
0234             obj.data = reshape(obj.data,sz0(1),prod(sz0(2:end)));
0235             
0236             <span class="comment">% Add NaNs where needed</span>
0237                 <span class="comment">% Note: to understand what this is doing, it really helps</span>
0238                 <span class="comment">% to draw a diagram!</span>
0239             sz = <a href="#_sub13" class="code" title="subfunction varargout = size(obj,varargin)">size</a>(obj.data);
0240             empties = cellfun(@<a href="#_sub12" class="code" title="subfunction A = isempty(obj)">isempty</a>,obj.data);    <span class="comment">% 2D matrix with 1's marking empty cells</span>
0241             se = sum(empties,1);                    <span class="comment">% Number of empties per column in this matrix</span>
0242             bad_inds = se ~= 0 &amp; se ~= sz(2);     <span class="comment">% Good columns must be either all empty or all non-empty</span>
0243             
0244             <span class="keyword">if</span> any(bad_inds)
0245                 fprintf(<span class="string">'Note: Empty entries found along collapsing dim. Using NaNs as placeholders to fill out the matrix. \n'</span>);
0246                 bi = find(bad_inds);
0247                 <span class="keyword">for</span> j = 1:length(bi)                    <span class="comment">% Sweep through bad columns</span>
0248                     curr_bad = find(empties(:,j));      <span class="comment">% Empties along this particular column</span>
0249                     curr_good = find(~empties(:,j));    <span class="comment">% Non-empties along this particular column.</span>
0250                     <span class="keyword">for</span> i = 1:length(curr_bad)
0251                         <span class="comment">% Populate the empty cells with matrices of NaNs</span>
0252                         <span class="comment">% that are the same dimensionality as the first</span>
0253                         <span class="comment">% good entry.</span>
0254                         obj.data{curr_bad(i),bi(j)} = NaN*ones(<a href="#_sub13" class="code" title="subfunction varargout = size(obj,varargin)">size</a>(obj.data{curr_good(1),bi(j)}));
0255                     <span class="keyword">end</span>
0256                 <span class="keyword">end</span>
0257             <span class="keyword">end</span>
0258             
0259             <span class="comment">% Check that sizes and dimensionalities are compatible</span>
0260             data_ndims = cellfun(@<a href="#_sub14" class="code" title="subfunction Nd = ndims(obj)">ndims</a>,obj.data,<span class="string">'UniformOutput'</span>,true);
0261             <span class="keyword">if</span> any(any(data_ndims ~= repmat(data_ndims(1,:),sz(1),1),1),2)
0262                 error(<span class="string">'Dimensions of nDDict.data not uniform along packing dimensions.'</span>);
0263             <span class="keyword">end</span>
0264            
0265             
0266             data_sz = cellfun(@<a href="#_sub13" class="code" title="subfunction varargout = size(obj,varargin)">size</a>,obj.data,<span class="string">'UniformOutput'</span>,false);
0267             data_sz_firsts = repmat(data_sz(1,:),sz(1),1);
0268             myfunc = @(x,y) any(x(:) ~= y(:));
0269             bool_size_mismatch = cellfun(myfunc,data_sz,data_sz_firsts);
0270             <span class="keyword">if</span> any(bool_size_mismatch(:))
0271                 error(<span class="string">'Sizes of nDDict.data are not uniform along packing dimension. (This usually results form trying to combine populations with different numbers of cells.'</span>);
0272             <span class="keyword">end</span>
0273             
0274             <span class="comment">% Now, pack the data.</span>
0275 <span class="comment">%             for j = 1:sz(2)</span>
0276 <span class="comment">%                 % permute so that contents of each cell has the selected</span>
0277 <span class="comment">%                 % dimenison along dimension 1</span>
0278 <span class="comment">%                 for i = 1:sz(1)</span>
0279 <span class="comment">%                     dat_curr = obj.data{i,j};</span>
0280 <span class="comment">%                     Ndimdat = ndims(dat_curr);</span>
0281 <span class="comment">%                     dat_curr = permute(dat_curr,[dim, 1:dim-1, dim+1:Ndimdat]); %whos dat_curr</span>
0282 <span class="comment">%                     % dat_curr = permute(dat_curr,[2:dim, 1, dim+1:Ndimdat]);    %whos dat_curr       % Uncomment this stuff to make sure it permutes back</span>
0283 <span class="comment">%                     obj.data{i,j} = dat_curr;</span>
0284 <span class="comment">%                 end</span>
0285 <span class="comment">%</span>
0286 <span class="comment">%                 % Concatenate the data along dimension 1</span>
0287 <span class="comment">%                 data_new{j} = cat(1,obj.data{j,:});</span>
0288 <span class="comment">%</span>
0289 <span class="comment">%                 % Permute the contents of each cell back to original</span>
0290 <span class="comment">%                 for i = 1:sz(1)</span>
0291 <span class="comment">%                     dat_curr = data_new{j};</span>
0292 <span class="comment">%                     dat_curr = permute(dat_curr,[2:dim, 1, dim+1:Ndimdat]);     %whos dat_curr</span>
0293 <span class="comment">%                     data_new{j} = dat_curr;</span>
0294 <span class="comment">%                 end</span>
0295 <span class="comment">%</span>
0296 <span class="comment">%             end</span>
0297         
0298             <span class="keyword">for</span> j = 1:sz(2)
0299                 obj.data{1,j} = cat(dim_target,obj.data{:,j});
0300                 obj.data(2:<span class="keyword">end</span>,j) = cell(sz(1)-1,1);     <span class="comment">% Set remainder to empty</span>
0301             <span class="keyword">end</span>
0302             
0303             obj.data = obj.data(1,:);         <span class="comment">% Keep only 1st dimension;</span>
0304             sz(1) = 1;
0305             sz0(1) = 1;
0306 
0307             <span class="comment">% Lastly, restore original dimensions</span>
0308             <span class="comment">% of nDDict.data</span>
0309             obj.data = reshape(obj.data,sz0);
0310             obj.data = <a href="#_sub15" class="code" title="subfunction obj = permute(obj,order)">permute</a>(obj.data,[2:dim_src, 1, dim_src+1:Nd]);
0311             
0312             <span class="comment">% Also, update obj.axis</span>
0313 <span class="comment">%             obj.axis(dim_src).values = 1;</span>
0314             obj = <a href="#_sub19" class="code" title="subfunction obj = setAxisDefaultNames(obj,dim)">setAxisDefaultNames</a>(obj,dim_src);
0315             obj.axis(dim_src).name = [<span class="string">'Dim '</span> num2str(dim_src)];
0316             
0317         <span class="keyword">end</span>
0318         
0319         <a name="_sub8" href="#_subfunctions" class="code">function out = getaxisinfo(obj)</a>
0320             <span class="comment">% If no output arguments, prints axis info to the screen. If</span>
0321             <span class="comment">% output arguments are supplied, returns this information as a</span>
0322             <span class="comment">% strin.g</span>
0323             
0324             <span class="keyword">if</span> nargout &gt; 0
0325                 out = <span class="string">''</span>;
0326             <span class="keyword">end</span>
0327             
0328             <span class="keyword">if</span> <a href="#_sub12" class="code" title="subfunction A = isempty(obj)">isempty</a>(obj.data)
0329                 <span class="keyword">if</span> nargout &gt; 0; out = <span class="string">'Object is empty'</span>;
0330                 <span class="keyword">else</span> fprintf(<span class="string">'Object is empty \n'</span>);
0331                 <span class="keyword">end</span>
0332                 <span class="keyword">return</span>;
0333             <span class="keyword">end</span>
0334             
0335             <span class="keyword">for</span> i = 1:length(obj.axis)
0336                 
0337                 out1 = obj.axis(i).getaxisinfo;
0338                 temp = <span class="string">''</span>;
0339                 
0340                 <span class="keyword">if</span> nargout &gt; 0
0341                     out = [out, temp, out1, <span class="string">'; '</span> ];
0342                 <span class="keyword">else</span>
0343                     temp = [<span class="string">'Axis '</span>, num2str(i), <span class="string">': '</span>];
0344                     fprintf([temp, out1, <span class="string">'\n'</span>]);
0345                 <span class="keyword">end</span>
0346             <span class="keyword">end</span>
0347             
0348             <span class="comment">% Lastly output a summary of dimensionality comparing nDDict.axis</span>
0349             <span class="comment">% and nDDict.data. These should match up.</span>
0350             <span class="keyword">if</span> nargout == 0
0351                 fprintf([<span class="string">'nDDict.axis dimensionality '</span> num2str(cellfun(@length,{obj.axis.values})) <span class="string">'\n'</span>]);
0352                 fprintf([<span class="string">'nDDict.data dimensionality '</span> num2str(<a href="#_sub13" class="code" title="subfunction varargout = size(obj,varargin)">size</a>(obj.data)) <span class="string">'\n'</span>]);
0353             <span class="keyword">end</span>
0354         <span class="keyword">end</span>
0355         
0356         <span class="comment">% % % % % % % % % % % HOUSEKEEPING FUNCTIONS % % % % % % % % % % %</span>
0357         <a name="_sub9" href="#_subfunctions" class="code">function obj = fixAxes(obj)</a>
0358             <span class="comment">% This function forces the nDDict axis data to be updated to</span>
0359             <span class="comment">% match the dimensions of the data structure.</span>
0360             <span class="comment">% The convention of nDDict is to have always follow MATLAB</span>
0361             <span class="comment">% conventions for dimensionality. Thus, the size(obj.data)</span>
0362             <span class="comment">% command is used to determine the correct number of axes, and</span>
0363             <span class="comment">% axis is adjusted to match, adding or removing dimensions as</span>
0364             <span class="comment">% needed. If you are getting errors when running checkDims, you</span>
0365             <span class="comment">% should run this command.</span>
0366             <span class="comment">%</span>
0367             <span class="comment">% The one exception to MATLAB conventions is that there are</span>
0368             <span class="comment">% allowed to be more axes than there are dimensions in obj.data</span>
0369             <span class="comment">% as long as the number of entries in each of these axes is 1.</span>
0370 
0371             Nd = <a href="#_sub14" class="code" title="subfunction Nd = ndims(obj)">ndims</a>(obj.data);
0372             Na = length(obj.axis);
0373 
0374             <span class="comment">% Sweep through all axes and make sure dimensions are correct.</span>
0375             <span class="comment">% Add new axes if needed, up to Nd.</span>
0376             <span class="keyword">for</span> i = 1:Nd
0377                 obj = <a href="#_sub19" class="code" title="subfunction obj = setAxisDefaultNames(obj,dim)">setAxisDefaultNames</a>(obj,i);  <span class="comment">% Sets axis #i to the default name</span>
0378             <span class="keyword">end</span>
0379 
0380             <span class="comment">% Trim away excess values in axes</span>
0381             <span class="keyword">if</span> Na &gt; Nd
0382                 <span class="keyword">for</span> i = Nd+1:Na
0383                     <span class="keyword">if</span> length(obj.axis(i).values) &gt; 1
0384                         obj.axis(i).values = obj.axis(i).values(1);
0385                         fprintf([<span class="string">'Extra values found in axis #'</span> num2str(i) <span class="string">' '</span> obj.axis(i).name <span class="string">'. Trimming \n'</span>]);
0386                     <span class="keyword">end</span>
0387                 <span class="keyword">end</span>
0388                 
0389             <span class="keyword">end</span>
0390             
0391         <span class="keyword">end</span>
0392         
0393         
0394         <a name="_sub10" href="#_subfunctions" class="code">function checkDims(obj)</a>
0395             <span class="comment">% We enforce that size(obj.data) must always match up to</span>
0396             <span class="comment">% length(obj.axis(i).values) for all i. We allow there to be</span>
0397             <span class="comment">% more axis than ndims(obj.data), but only if these axes have</span>
0398             <span class="comment">% lengths of 1.</span>
0399             
0400             <span class="comment">% Note, fixAxes fixes everything automatically.</span>
0401             <span class="comment">% Only call checkDims if you want to</span>
0402             <span class="comment">% be alerted to mismatches, but not to correct them. Use fixAxes to</span>
0403             <span class="comment">% automatically correct everything.</span>
0404             
0405             <span class="keyword">if</span> <a href="#_sub12" class="code" title="subfunction A = isempty(obj)">isempty</a>(obj); error(<span class="string">'Object is empty. Input some data first!'</span>); <span class="keyword">return</span>; <span class="keyword">end</span>
0406             
0407             sza = arrayfun(@(x) length(x.values),obj.axis);
0408             szd = <a href="#_sub13" class="code" title="subfunction varargout = size(obj,varargin)">size</a>(obj.data);
0409             
0410             Nd = <a href="#_sub14" class="code" title="subfunction Nd = ndims(obj)">ndims</a>(obj.data);
0411             Na = length(obj.axis);
0412 
0413             <span class="keyword">if</span> Nd &gt; Na
0414                 error(<span class="string">'checkDims: Error found! Number of dimensions in nDDict.data does not equal number of axes'</span>);
0415             <span class="keyword">end</span>
0416 
0417             <span class="comment">% For all dimensions in obj.data</span>
0418             <span class="keyword">for</span> i = 1:Nd
0419                 <span class="keyword">if</span> sza(i) ~= szd(i)
0420                     fprintf([<span class="string">'checkDims: Error found! obj.data dimension '</span>,num2str(i), <span class="keyword">...</span>
0421                         <span class="string">' is '</span>, num2str(szd(i)) , <span class="keyword">...</span>
0422                         <span class="string">'. But corresponding axis \&quot;'</span>, obj.axis(i).name , <span class="keyword">...</span>
0423                         <span class="string">'\&quot; has '</span>, num2str(sza(i)) , <span class="string">' values. Dimension mismatch. \nTry running nDDict.getaxisinfo and then nDDict.fixAxes. \n'</span> ]);
0424                     error(<span class="string">' '</span>);
0425                 <span class="keyword">end</span>
0426             <span class="keyword">end</span>
0427             
0428             <span class="comment">% For additional axes beyond ndims(obj.data)</span>
0429             ind = sza &gt; 1;
0430             <span class="keyword">if</span> any(ind(Nd+1:Na))
0431                 ind2 = find(ind);
0432                 ind2 = ind2(ind2 &gt; Nd);
0433                 fprintf([<span class="string">'checkDims: Error found! ndims(obj.data)='</span> num2str(Nd) <span class="string">' but axis obj.axis('</span> num2str(ind2) <span class="string">').values has '</span> num2str(sza(ind2)) <span class="string">' entries.\n'</span>]);
0434                 error(<span class="string">' '</span>);
0435             <span class="keyword">end</span>
0436             
0437             <span class="comment">% All good if make it to here</span>
0438         <span class="keyword">end</span>
0439 
0440         
0441         <span class="comment">% % % % % % % % % % % OVERLOADED FUNCTIONS % % % % % % % % % % %</span>
0442         
0443         <a name="_sub11" href="#_subfunctions" class="code">function A = isempty(obj)</a>
0444             A = <a href="#_sub12" class="code" title="subfunction A = isempty(obj)">isempty</a>(obj.data);
0445         <span class="keyword">end</span>
0446         
0447         <a name="_sub12" href="#_subfunctions" class="code">function varargout = size(obj,varargin)</a>
0448             <span class="comment">% Returns size of obj. This function is basically the same as</span>
0449             <span class="comment">% running size(obj.data) except we base it off of the dimensions</span>
0450             <span class="comment">% of obj.axis rather than obj.data. This has the effect of</span>
0451             <span class="comment">% returning 1's if length(obj.axis) &gt; ndims(obj.data)</span>
0452             
0453             <a href="#_sub11" class="code" title="subfunction checkDims(obj)">checkDims</a>(obj);
0454             
0455             [varargout{1:nargout}] = <a href="#_sub13" class="code" title="subfunction varargout = size(obj,varargin)">size</a>(obj.data,varargin{:});
0456             
0457             <span class="comment">% If function is called in the form sz = size(obj) OR size(obj),</span>
0458             <span class="comment">% return the length of each axis.</span>
0459             <span class="keyword">if</span> nargout &lt;= 1 &amp;&amp; nargin == 1
0460                 Na = length(obj.axis);
0461                 sz = zeros(1,Na);
0462                 <span class="keyword">for</span> i = 1:Na
0463                     sz(i) = length(obj.axis(i).values);
0464                 <span class="keyword">end</span>
0465                 <span class="keyword">if</span> nargout == 1; varargout{1} = sz; <span class="keyword">end</span>
0466             <span class="keyword">end</span>
0467         <span class="keyword">end</span>
0468         
0469         <a name="_sub13" href="#_subfunctions" class="code">function Nd = ndims(obj)</a>
0470             <a href="#_sub11" class="code" title="subfunction checkDims(obj)">checkDims</a>(obj);
0471             Nd = length(obj.axis);
0472         <span class="keyword">end</span>
0473         
0474         <a name="_sub14" href="#_subfunctions" class="code">function obj = permute(obj,order)</a>
0475             <a href="#_sub11" class="code" title="subfunction checkDims(obj)">checkDims</a>(obj);
0476             obj.data = <a href="#_sub15" class="code" title="subfunction obj = permute(obj,order)">permute</a>(obj.data,order);
0477             obj.axis = obj.axis(order);
0478         <span class="keyword">end</span>
0479         
0480         
0481         <a name="_sub15" href="#_subfunctions" class="code">function obj = transpose(obj)</a>
0482             <a href="#_sub11" class="code" title="subfunction checkDims(obj)">checkDims</a>(obj);
0483             Nd = <a href="#_sub14" class="code" title="subfunction Nd = ndims(obj)">ndims</a>(obj.data);
0484             
0485             <span class="keyword">if</span> Nd &gt; 2; error(<span class="string">'Can only transpose data with at most 2 dimensions'</span>);
0486             <span class="keyword">end</span>
0487             
0488             obj.data = obj.data';
0489             obj.axis([1,2]) = obj.axis([2,1]);        <span class="comment">% Axis should always be at least length=2.</span>
0490         <span class="keyword">end</span>
0491         
0492         <a name="_sub16" href="#_subfunctions" class="code">function obj = squeeze(obj)</a>
0493             <span class="comment">% This is just like MATLAB's normal squeeze command. However,</span>
0494             <span class="comment">% there is one key difference:</span>
0495             <span class="comment">% Normally, if squeeze operates on a 1xN matrix, it will leave</span>
0496             <span class="comment">% it as 1xN. This function forces it to always return as Nx1</span>
0497             
0498             <a href="#_sub11" class="code" title="subfunction checkDims(obj)">checkDims</a>(obj);
0499             
0500             <span class="comment">% If data is bigger than a matrix, squeeze out dimensions that</span>
0501             <span class="comment">% are of size 1.</span>
0502             sz = <a href="#_sub13" class="code" title="subfunction varargout = size(obj,varargin)">size</a>(obj.data);
0503             <span class="keyword">if</span> length(sz) &gt; 2
0504                 ind = sz~=1;
0505                 obj.axis = obj.axis(ind);
0506 
0507                 <span class="comment">% Now squeeze obj.data</span>
0508                 obj.data = <a href="#_sub17" class="code" title="subfunction obj = squeeze(obj)">squeeze</a>(obj.data);         <span class="comment">% Normal squeeze command</span>
0509 
0510 <span class="comment">%                 % Lastly, if the result is a row vector, force it to be a</span>
0511 <span class="comment">%                 % column vector</span>
0512 <span class="comment">%                 if isvector(obj.data) &amp;&amp; ~iscolumn(obj.data)</span>
0513 <span class="comment">%                     obj.data = obj.data';</span>
0514 <span class="comment">%                 end</span>
0515             <span class="keyword">else</span>
0516                 <span class="comment">% Otherwise, if data is a matrix, remove all axis beyond</span>
0517                 <span class="comment">% the first two. These should only be size 1 (e.g. &quot;name&quot;</span>
0518                 <span class="comment">% axes anyways)</span>
0519 <span class="comment">%                 szA = cellfun(@length,{obj.axis.values});</span>
0520 <span class="comment">%                 ind = szA~=1;</span>
0521 <span class="comment">%                 ind(1:2) = true;</span>
0522                 obj.axis = obj.axis(1:2);
0523             <span class="keyword">end</span>
0524             
0525             <span class="comment">% Make sure everything is good before returning.</span>
0526             obj = obj.fixAxes;
0527             <a href="#_sub11" class="code" title="subfunction checkDims(obj)">checkDims</a>(obj);
0528         <span class="keyword">end</span>
0529         
0530         <span class="comment">% % % % % % % % % % % END % % % % % % % % % % %</span>
0531     <span class="keyword">end</span>
0532 <span class="keyword">end</span>
0533 
0534 
0535 <a name="_sub17" href="#_subfunctions" class="code">function output = inheritObj(output,input)</a>
0536     <span class="comment">% Merges contents of input into output.</span>
0537     C = metaclass(input);
0538     P = C.Properties;
0539     <span class="keyword">for</span> k = 1:length(P)
0540         <span class="keyword">if</span> ~P{k}.Dependent
0541             output.(P{k}.Name) = input.(P{k}.Name);
0542         <span class="keyword">end</span>
0543     <span class="keyword">end</span>
0544 <span class="keyword">end</span>
0545 
0546 
0547 
0548 
0549 <a name="_sub18" href="#_subfunctions" class="code">function obj = setAxisDefaultNames(obj,dim)</a>
0550     <span class="comment">% Sets obj.axis(i) to default values</span>
0551     
0552     <span class="comment">% Get desired size of dataset</span>
0553     sz_dim = <a href="#_sub13" class="code" title="subfunction varargout = size(obj,varargin)">size</a>(obj.data,dim);
0554     
0555     <span class="comment">% If axis doesn't already exist, create it. Otherwise, copy existing.</span>
0556     <span class="keyword">if</span> length(obj.axis) &lt; dim
0557         ax_curr = <a href="../../../functions_xPlt/classes/nDDictAxis.html" class="code" title="">nDDictAxis</a>;
0558     <span class="keyword">else</span>
0559         ax_curr = obj.axis(dim);
0560     <span class="keyword">end</span>
0561     
0562     <span class="comment">% Name it if necessary</span>
0563     <span class="keyword">if</span> <a href="#_sub12" class="code" title="subfunction A = isempty(obj)">isempty</a>(ax_curr.name)
0564         ax_curr.name = [<span class="string">'Dim '</span> num2str(dim)];
0565     <span class="keyword">end</span>
0566     
0567     <span class="comment">% If values is empty, add default values.</span>
0568     <span class="keyword">if</span> <a href="#_sub12" class="code" title="subfunction A = isempty(obj)">isempty</a>(ax_curr.values)
0569         <span class="comment">%ax_curr.values = cellfun(@num2str,num2cell(1:sz(i)),'UniformOutput',0);     % Populate with strings</span>
0570         ax_curr.values = 1:sz_dim;                                                   <span class="comment">% Populate with numerics</span>
0571     <span class="keyword">else</span>
0572         <span class="comment">% Otherwise, make sure dimensionality is correct. If not, update it</span>
0573         <span class="comment">% missing entries with default names.</span>
0574         N = length(ax_curr.values);
0575         <span class="keyword">if</span> N &lt; sz_dim
0576             <span class="keyword">if</span> isnumeric(ax_curr.values)
0577                 <span class="keyword">for</span> j = N:sz_dim; ax_curr.values(j) = j; <span class="keyword">end</span>
0578             <span class="keyword">else</span>
0579                 <span class="keyword">for</span> j = N:sz_dim; ax_curr.values{j} = num2str(j); <span class="keyword">end</span>
0580             <span class="keyword">end</span>
0581         <span class="keyword">end</span>
0582         
0583         <span class="keyword">if</span> N &gt; sz_dim
0584             <span class="comment">%ax_curr.values = ax_curr.values(1:sz(dim));</span>
0585             ax_curr.values = 1:sz_dim;                                                   <span class="comment">% Populate with genetic numerics</span>
0586         <span class="keyword">end</span>
0587     <span class="keyword">end</span>
0588     
0589     obj.axis(dim) = ax_curr;
0590 <span class="keyword">end</span>
0591 
0592 
0593 <a name="_sub19" href="#_subfunctions" class="code">function [selection_out, startIndex] = regex_lookup(vals, selection)</a>
0594     <span class="keyword">if</span> ~ischar(vals{1}); error(<span class="string">'nDDict.axis.values must be strings when using regular expressions'</span>);
0595     <span class="keyword">end</span>
0596     <span class="keyword">if</span> ~ischar(selection); error(<span class="string">'Selection must be string when using regexp'</span>);
0597     <span class="keyword">end</span>
0598     
0599     startIndex = regexp(vals,selection);
0600     selection_out = logical(~cellfun(@<a href="#_sub12" class="code" title="subfunction A = isempty(obj)">isempty</a>,startIndex));
0601     selection_out = find(selection_out);
0602     
0603 <span class="keyword">end</span>
0604 
0605 <span class="comment">% function varargout = size2(varargin)</span>
0606 <span class="comment">%     [varargout{1:nargout}] = size(varargin{:});</span>
0607 <span class="comment">%     if nargout == 1</span>
0608 <span class="comment">%         sz = varargout{1};</span>
0609 <span class="comment">%         if length(sz) == 2 &amp;&amp; sz(2) == 1</span>
0610 <span class="comment">%             sz = sz(1);</span>
0611 <span class="comment">%         end</span>
0612 <span class="comment">%         varargout{1} = sz;</span>
0613 <span class="comment">%     end</span>
0614 <span class="comment">% end</span></pre></div>
<hr><address>Generated on Mon 27-Feb-2017 14:58:50 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>