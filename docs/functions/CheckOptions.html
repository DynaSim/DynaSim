<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of ds.checkOptions</title>
  <meta name="keywords" content="ds.checkOptions">
  <meta name="description" content="CHECKOPTIONS - organize key/value pairs in structure with default or user-supplied values according to a schema">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- menu.html functions -->
<h1>ds.checkOptions
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>CHECKOPTIONS - organize key/value pairs in structure with default or user-supplied values according to a schema</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function [parms, params_unspecified ] = ds.checkOptions(options, options_schema, strict) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment">CHECKOPTIONS - organize key/value pairs in structure with default or user-supplied values according to a schema

 Usage:
   options = ds.checkOptions(keyvals, options_schema, [strict])

 Inputs:
   - keyvals: list of key/value pairs ('option1',value1,'option2',value2,...)
   - options_schema: cell array containing 3 values per known 'option':
     - option name
     - default value
     - allowed values:
         - vector of true/false values
         - vector of min/max values
         - vector of allowed values (more than 2 elements)
         - cell array of allowed values
         - empty to specify no limitations.
   - strict (default: true): whether to fail if options not specified in the
       options_schema are found.

 Note: this function was adapted from one developed &quot;in-house&quot; years ago...

 Outputs:
   - options: structure with options (using default values if not supplied)

 See also: <a href="ds.options2Keyval.html" class="code" title="function keyval = ds.options2Keyval(options)">ds.options2Keyval</a>, <a href="ds.checkSpecification.html" class="code" title="function spec=ds.checkSpecification(specification)">ds.checkSpecification</a>, <a href="ds.checkModel.html" class="code" title="function model=ds.checkModel(model)">ds.checkModel</a>, <a href="ds.checkData.html" class="code" title="function data=ds.checkData(data)">ds.checkData</a></pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="dsAnalyze.html" class="code" title="function result=dsAnalyze(data,func,varargin)">dsAnalyze</a>	DSANALYZE - Apply an analysis function to DynaSim data, optionally saving data</li><li><a href="AnalyzeStudy.html" class="code" title="function [results,studyinfo]=AnalyzeStudy(data,func,varargin)">AnalyzeStudy</a>	ANALYZESTUDY - Apply an analysis function to DynaSim data, optionally saving data</li><li><a href="ds.calcACF.html" class="code" title="function data = ds.calcACF(data,varargin)">ds.calcACF</a>	CALCACF - Calculate the autocorrelation function.</li><li><a href="ds.calcCellProperties.html" class="code" title="function stats = ds.calcCellProperties(data,varargin)">ds.calcCellProperties</a>	CALCCELLPROPERTIES - calculates the intrinsic electrophysiological properties of all cells in one or more populations</li><li><a href="ds.calcFR.html" class="code" title="function data = ds.calcFR(data,varargin)">ds.calcFR</a>	CALCFR - Calculate firing rage for DynaSim data</li><li><a href="ds.calcFRmulti.html" class="code" title="function data = ds.calcFRmulti(data,varargin)">ds.calcFRmulti</a>	CALCFRMULTI - extends ds.calcFR to get SUA and MUA firing rates</li><li><a href="ds.calcISI.html" class="code" title="function data = ds.calcISI(data,varargin)">ds.calcISI</a>	CALCISI - Calculate the interspike interval.</li><li><a href="ds.calcPower.html" class="code" title="function data = ds.calcPower(data,varargin)">ds.calcPower</a>	CALCPOWER - Compute spectral analysis of DynaSim data</li><li><a href="ds.calcSpikeSync.html" class="code" title="function stats = ds.calcSpikeSync(data,varargin)">ds.calcSpikeSync</a>	CALCSPIKESYNC - Compute spike synchronization between spiketrains</li><li><a href="ds.checkSolverOptions.html" class="code" title="function options=ds.checkSolverOptions(options)">ds.checkSolverOptions</a>	CHECKSOLVEROPTIONS - standardize simulation options appended to params.mat</li><li><a href="ds.checkStudyinfo.html" class="code" title="function studyinfo=ds.checkStudyinfo(studyinfo,varargin)">ds.checkStudyinfo</a>	CHECKSTUDYINFO - Standardize studyinfo structure and auto-populate missing fields</li><li><a href="ds.createBatch.html" class="code" title="function studyinfo = ds.createBatch(base_model,modifications_set,varargin)">ds.createBatch</a>	CREATEBATCH - create and submit jobs to run sets of simulations or analyses.</li><li><a href="ds.exportData.html" class="code" title="function ds.exportData(data,varargin)">ds.exportData</a>	EXPORTDATA - export DynaSim data structure in various formats.</li><li><a href="ds.generateModel.html" class="code" title="function [model,name_map]=ds.generateModel(specification,varargin)">ds.generateModel</a>	GENERATEMODEL - Parse DynaSim specification and organize model data in DynaSim model structure</li><li><a href="ds.getSolveFile.html" class="code" title="function solve_file = ds.getSolveFile(model,studyinfo,varargin)">ds.getSolveFile</a>	GETSOLVEFILE - helper function that creates or retrieves the desired solver file.</li><li><a href="ds.importData.html" class="code" title="function [data,studyinfo] = ds.importData(file,varargin)">ds.importData</a>	IMPORTDATA - load data into DynaSim formatted data structure.</li><li><a href="ds.importModel.html" class="code" title="function [model,map] = ds.importModel(source,varargin)">ds.importModel</a>	IMPORTMODEL - import model from raw equations, other program source, etc.</li><li><a href="ds.importPlots.html" class="code" title="function [data,studyinfo] = ds.importPlots(file,varargin)">ds.importPlots</a>	IMPORTPLOTS - load info about saved images (generated by SimulateMode or dsAnalyze) alongwith corresponding varied model components.</li><li><a href="ds.monitorStudy.html" class="code" title="function [studyinfo,study_status]=ds.monitorStudy(studyinfo,varargin)">ds.monitorStudy</a>	MONITORSTUDY - display information on study progress.</li><li><a href="dsPlot.html" class="code" title="function handles = dsPlot(data,varargin)">dsPlot</a>	PLOTDATA - plot data in various ways depending on what data was provided and what options are defined.</li><li><a href="dsPlot2.html" class="code" title="function [handles,xp]=dsPlot2(data,varargin)">dsPlot2</a>	% handles=dsPlot(data,'option',value)</li><li><a href="ds.plotFR2.html" class="code" title="function handles=ds.plotFR2(data,varargin)">ds.plotFR2</a>	PLOTFR2 - plot spike rates in various ways depending on what data was provided.</li><li><a href="ds.plotStudy.html" class="code" title="function [handles, hsp, h2]=ds.plotStudy(data,myplot_handle,varargin)">ds.plotStudy</a>	PLOTSTUDY - Applies a user-specified plotting function to each element of data structure.</li><li><a href="ds.plotWaveforms.html" class="code" title="function ds.plotWaveforms(data,varargin)">ds.plotWaveforms</a>	PLOTWAVEFORMS - plot waveforms in various ways depending on what data was provided.</li><li><a href="ds.prepareMEX.html" class="code" title="function mexfileOutput = ds.prepareMEX(mfileInput, varargin)">ds.prepareMEX</a>	PREPAREMEX - take an m-file path and compile it using the Matlab coder.</li><li><a href="ds.probeCellProperties.html" class="code" title="function data = ds.probeCellProperties(model,varargin)">ds.probeCellProperties</a>	data = ds.probeCellProperties(model,'option1',option1,...)</li><li><a href="ds.probeFI.html" class="code" title="function data=ds.probeFI(model,varargin)">ds.probeFI</a>	% data=ds.probeFI(model,varargin)</li><li><a href="ds.propagateParameters.html" class="code" title="function model=ds.propagateParameters(model,varargin)">ds.propagateParameters</a>	PROPAGATEPARAMETERS - substitute parameter values or prepend parameter names with prefix across all model equations.</li><li><a href="dsSelect.html" class="code" title="function data=dsSelect(data,varargin)">dsSelect</a>	SELECTDATA -  select subset of data</li><li><a href="ds.setupStudy.html" class="code" title="function [studyinfo,options]=ds.setupStudy(base_model,varargin)">ds.setupStudy</a>	SETUPSTUDY - Initialize DynaSim studyinfo structure, prepare list of output file names, and create output directories</li><li><a href="dsSimulate.html" class="code" title="function [data,studyinfo]=dsSimulate(model,varargin)">dsSimulate</a>	% data=dsSimulate(model,'option',value,...)</li><li><a href="ds.updateStudy.html" class="code" title="function studyinfo=ds.updateStudy(study_dir,varargin)">ds.updateStudy</a>	UPDATESTUDY - helper function to keep track of study metadata when anything is saved</li><li><a href="ds.writeDynaSimSolver.html" class="code" title="function [outfile,options]=ds.writeDynaSimSolver(model,varargin)">ds.writeDynaSimSolver</a>	WRITEDYNASIMSOLVER - write m-file that numerically inteegrates the model</li><li><a href="ds.writeMatlabSolver.html" class="code" title="function solve_ode_filepath = ds.writeMatlabSolver(model,varargin)">ds.writeMatlabSolver</a>	WRITEMATLABSOLVER - write m-file that numerically inteegrates the model</li><li><a href="ds.dynasim2odefun.html" class="code" title="function [ODEFUN,IC,elem_names]=ds.dynasim2odefun(model, varargin)">ds.dynasim2odefun</a>	Purpose: prepare ODEFUN for use with built-in Matlab solvers.</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [parms, params_unspecified ] = ds.checkOptions(options, options_schema, strict)</a>
0002 <span class="comment">%CHECKOPTIONS - organize key/value pairs in structure with default or user-supplied values according to a schema</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% Usage:</span>
0005 <span class="comment">%   options = ds.checkOptions(keyvals, options_schema, [strict])</span>
0006 <span class="comment">%</span>
0007 <span class="comment">% Inputs:</span>
0008 <span class="comment">%   - keyvals: list of key/value pairs ('option1',value1,'option2',value2,...)</span>
0009 <span class="comment">%   - options_schema: cell array containing 3 values per known 'option':</span>
0010 <span class="comment">%     - option name</span>
0011 <span class="comment">%     - default value</span>
0012 <span class="comment">%     - allowed values:</span>
0013 <span class="comment">%         - vector of true/false values</span>
0014 <span class="comment">%         - vector of min/max values</span>
0015 <span class="comment">%         - vector of allowed values (more than 2 elements)</span>
0016 <span class="comment">%         - cell array of allowed values</span>
0017 <span class="comment">%         - empty to specify no limitations.</span>
0018 <span class="comment">%   - strict (default: true): whether to fail if options not specified in the</span>
0019 <span class="comment">%       options_schema are found.</span>
0020 <span class="comment">%</span>
0021 <span class="comment">% Note: this function was adapted from one developed &quot;in-house&quot; years ago...</span>
0022 <span class="comment">%</span>
0023 <span class="comment">% Outputs:</span>
0024 <span class="comment">%   - options: structure with options (using default values if not supplied)</span>
0025 <span class="comment">%</span>
0026 <span class="comment">% See also: ds.options2Keyval, ds.checkSpecification, ds.checkModel, ds.checkData</span>
0027 
0028 
0029 <span class="comment">% Convert cell argument to struct if contains struct (Leave as is if already a struct)</span>
0030 <span class="keyword">if</span> length(options) == 1 &amp;&amp; ~isstruct(options) &amp;&amp; isstruct(options{1})
0031   options = options{1};
0032 <span class="keyword">end</span>
0033 
0034 <span class="keyword">if</span> ~isstruct(options) &amp;&amp; (0 ~= mod(length(options),2))     <span class="comment">%   Validate that the # of args is even</span>
0035   error(<span class="string">'List of arguments must be even (must have name/value pair)'</span>);
0036 <span class="keyword">end</span>
0037 <span class="keyword">if</span> (0 ~= mod(length(options_schema),3))    <span class="comment">%   Validate the options_schema info is right</span>
0038   error(<span class="string">'Programming error: list of default arguments must be even (must have name/value pair)'</span>);
0039 <span class="keyword">end</span>
0040 <span class="keyword">if</span> (~exist(<span class="string">'strict'</span>, <span class="string">'var'</span>))
0041   strict = true;
0042 <span class="keyword">end</span>
0043 
0044 parms = [];
0045 
0046 <span class="comment">%   Rip all cell arguments into non-cell arguments?</span>
0047 <span class="comment">%     NOTE: currently just converts empty cells into empty arrays</span>
0048 <span class="keyword">if</span> ~isstruct(options)
0049   <span class="keyword">for</span> ind = 1:length(options)
0050     <span class="keyword">if</span> iscell(options{ind})
0051       <span class="keyword">if</span> isempty(options{ind})
0052         options{ind}=[];
0053       <span class="keyword">elseif</span> ~iscell(options{ind}{1})
0054         <span class="comment">%options{index} = { options{index} };</span>
0055       <span class="keyword">end</span>
0056     <span class="keyword">end</span>
0057   <span class="keyword">end</span>
0058 <span class="keyword">else</span>
0059   flds = fieldnames(options);
0060   <span class="keyword">for</span> ind = 1:length(flds)
0061     fld = flds{ind};
0062     <span class="keyword">if</span> iscell(options.(fld))
0063       <span class="keyword">if</span> isempty(options.(fld))
0064         options.(fld)=[];
0065       <span class="keyword">elseif</span> ~iscell(options.(fld){1})
0066         <span class="comment">%options{index} = { options{index} };</span>
0067       <span class="keyword">end</span>
0068     <span class="keyword">end</span>
0069   <span class="keyword">end</span>
0070 <span class="keyword">end</span>
0071 
0072 <span class="keyword">if</span> ~isstruct(options) <span class="comment">% if arguments given as list</span>
0073   input_fields  = options(1:2:end);
0074 <span class="keyword">else</span>
0075   input_fields  = fieldnames(options);
0076 <span class="keyword">end</span>
0077 valid_fields    = options_schema(1:3:end);
0078 unknown_fields  = setdiff(input_fields, valid_fields);
0079 
0080 <span class="comment">%   Validate that there are no extraneous params sent in</span>
0081 <span class="keyword">if</span> (strict &amp;&amp; ~isempty(unknown_fields))
0082   error(<span class="string">'The following unrecogized options were passed in: %s'</span>, sprintf(<span class="string">'%s '</span>,unknown_fields{:}));
0083 <span class="keyword">end</span>
0084 
0085 <span class="keyword">if</span> ~isstruct(options) <span class="comment">%convert to struct if arguments given as list</span>
0086   <span class="keyword">if</span> (~isempty( options ))
0087     <span class="keyword">for</span> f=1:length(options)/2
0088       parms.(options{2*f-1})=options{2*f};
0089     <span class="keyword">end</span>
0090     <span class="comment">%parms=struct(options{:});</span>
0091   <span class="keyword">end</span>
0092 <span class="keyword">else</span>
0093   parms = options;
0094 <span class="keyword">end</span>
0095 
0096 <span class="comment">%   This allows 'pass-through' of parameters;</span>
0097 <span class="comment">%   remove any fields that are unknown</span>
0098 <span class="comment">%   unless no schema is defined.</span>
0099 
0100 params_unspecified = struct;
0101 <span class="keyword">if</span> (~strict &amp;&amp; ~isempty(parms) &amp;&amp; ~isempty(options_schema))
0102   <span class="keyword">for</span> i = 1:length(unknown_fields)
0103       params_unspecified.(unknown_fields{i}) = parms.(unknown_fields{i});
0104   <span class="keyword">end</span>
0105   parms = rmfield(parms,unknown_fields);
0106 <span class="keyword">end</span>
0107 
0108 <span class="comment">%   Check arg values and set defaults</span>
0109 <span class="keyword">for</span> f=1:3:length(options_schema)
0110   <span class="comment">%   The value has been set explicitly by the caller;</span>
0111   <span class="comment">%   Validate the input parameters by the 'range' field</span>
0112   <span class="keyword">if</span>  (isfield(parms,options_schema{f}))
0113     param_name        = options_schema{f};
0114     param_value        = getfield(parms,param_name);
0115     param_range   = options_schema{f+2};
0116 
0117     <span class="comment">% no value was specified,</span>
0118     <span class="keyword">if</span> isempty(param_value)
0119       parms = setfield(parms, options_schema{f}, options_schema{f+1});
0120     <span class="comment">% no range was specified,</span>
0121     <span class="keyword">elseif</span> isempty(param_range)
0122       <span class="keyword">continue</span>;
0123      <span class="comment">%    param range is a cell array of strings; make sure the current value is within that range.</span>
0124     <span class="keyword">elseif</span> iscell(param_range)
0125       num_flag = 0;
0126       char_flag = 0;
0127       
0128       <span class="keyword">for</span> i=1:length(param_range)
0129         <span class="keyword">if</span> isnumeric(param_range{i}), num_flag=1; <span class="keyword">end</span>
0130         <span class="keyword">if</span> ischar(param_range{i}), char_flag=1; <span class="keyword">end</span>
0131       <span class="keyword">end</span>
0132       
0133       <span class="keyword">if</span> num_flag &amp;&amp; char_flag
0134         error(<span class="string">'type of parameter range (cell array of numbers and strings) specified for parameter ''%s'' is currently unsupported'</span>, options_schema{f});
0135       <span class="keyword">elseif</span> char_flag
0136         <span class="keyword">if</span> iscell(param_value)
0137           <span class="keyword">for</span> i=1:length(param_value)
0138             <span class="keyword">if</span> ~ischar(param_value{i})
0139               error(<span class="string">'parameter ''%s'' must be string or cell array of strings'</span>, options_schema{f});
0140             <span class="keyword">end</span>
0141           <span class="keyword">end</span>
0142         <span class="keyword">elseif</span> ~ischar(param_value)
0143           error(<span class="string">'parameter ''%s'' must be string or cell array of strings'</span>, options_schema{f});
0144         <span class="keyword">else</span>
0145           param_value = {param_value};
0146         <span class="keyword">end</span>
0147         
0148         <span class="keyword">if</span> length(find(ismember(param_value,param_range))) ~= length(param_value)
0149           error(<span class="string">'parameter ''%s'' value must be one of the following: { %s}'</span>, <span class="keyword">...</span>
0150             param_name, sprintf(<span class="string">'''%s'' '</span>,param_range{:}));
0151         <span class="keyword">end</span>
0152       <span class="keyword">elseif</span> num_flag
0153         param_range = cell2mat(param_range);
0154         
0155         <span class="keyword">if</span> ~isnumeric(param_value)
0156           error(<span class="string">'parameter ''%s'' must be numeric'</span>, options_schema{f});
0157         <span class="keyword">end</span>
0158         
0159         <span class="keyword">if</span> length(find(ismember(param_value,param_range))) ~= length(param_value)
0160           error(<span class="string">'parameter ''%s'' value must be one of the following: { %s}'</span>, <span class="keyword">...</span>
0161             param_name,sprintf(<span class="string">'%d '</span>,param_range));
0162         <span class="keyword">end</span>
0163       <span class="keyword">else</span>
0164         error(<span class="string">'type of parameter range specified for parameter ''%s'' is currently unsupported'</span>, options_schema{f});
0165       <span class="keyword">end</span>
0166     <span class="comment">%  param range is logical and has two elements (i.e. true/false)</span>
0167     <span class="keyword">elseif</span> islogical(param_range) &amp;&amp; length(param_range)==2
0168       <span class="keyword">if</span> ~ismember(param_value,param_range)
0169         error(<span class="string">'parameter %s value must be true (1) or false (0)'</span>, options_schema{f});
0170       <span class="keyword">end</span>
0171     <span class="comment">%  param range is numeric and has two elements (i.e. min and max)</span>
0172     <span class="keyword">elseif</span> isnumeric(param_range) &amp;&amp; length(param_range)==2
0173       <span class="comment">%  param range is numeric or logical, and within a specified range,</span>
0174       <span class="keyword">if</span> ~isempty(find(param_value &lt; param_range(1))) || <span class="keyword">...</span>
0175          ~isempty(find(param_value &gt; param_range(2)))
0176         <span class="keyword">if</span> int64(param_range(1))==param_range(1) &amp;&amp; int64(param_range(2))==param_range(2)
0177           error(<span class="string">'parameter %s value must be between %d and %d'</span>,<span class="keyword">...</span>
0178             options_schema{f},param_range(1),param_range(2));
0179         <span class="keyword">else</span>
0180           error(<span class="string">'parameter %s value must be between %0.4f and %0.4f'</span>,<span class="keyword">...</span>
0181             options_schema{f},param_range(1),param_range(2));
0182         <span class="keyword">end</span>
0183       <span class="keyword">end</span>
0184     <span class="comment">%  param range is numeric and has more than two elements (allowed values)</span>
0185     <span class="keyword">elseif</span> isnumeric(param_range)
0186       <span class="keyword">if</span> ~isnumeric(param_value)
0187         error(<span class="string">'parameter ''%s'' must be numeric'</span>, options_schema{f});
0188       <span class="keyword">end</span>
0189       
0190       <span class="keyword">if</span> length(find(ismember(param_value,param_range))) ~= length(param_value)
0191         error(<span class="string">'parameter ''%s'' value must be one of the following: [ %s]'</span>, <span class="keyword">...</span>
0192           param_name,sprintf(<span class="string">'%d '</span>,param_range));
0193       <span class="keyword">end</span>
0194     <span class="comment">%  param range is of a type we currently don't support.</span>
0195     <span class="keyword">else</span>
0196       error(<span class="string">'type of parameter range specified for parameter ''%s'' is currently unsupported'</span>, options_schema{f});
0197     <span class="keyword">end</span>
0198   <span class="comment">% field not found, so set the default value.</span>
0199   <span class="keyword">else</span>
0200     <span class="comment">%parms = setfield(parms, options_schema{f}, options_schema{f+1});</span>
0201     parms.(options_schema{f})=options_schema{f+1};
0202   <span class="keyword">end</span>
0203 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Fri 07-Apr-2017 20:01:20 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>