<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of getPopRhythmGating</title>
  <meta name="keywords" content="getPopRhythmGating">
  <meta name="description" content="function [sext,tstart,Pinputs,Psource,conn,T]=getPopRhythmGating(num_sources,num_targets,prob_conn,cell_FR,pop_freq,width,T,onset,offset,tau_syn,kick,seed,mask,ac_type)">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- menu.html functions -->
<h1>getPopRhythmGating
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function [sext,tstart,Pinputs,Psource,conn,T]=getPopRhythmGating(num_sources,num_targets,prob_conn,cell_FR,pop_freq,width,T,onset,offset,tau_syn,kick,seed,mask,ac_type)</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function [sext,tstart,Pinputs,Psource,conn,T,lambda]=getPopRhythmGating(num_sources,num_targets,prob_conn,cell_FR,pop_freq,width,T,onset,offset,tau_syn,kick,seed,mask,ac_type) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> function [sext,tstart,Pinputs,Psource,conn,T]=getPopRhythmGating(num_sources,num_targets,prob_conn,cell_FR,pop_freq,width,T,onset,offset,tau_syn,kick,seed,mask,ac_type)
 Purpose:
 generates sparse population rhythmic input for a target network with
 probabilistic input connectivity.
 network frequency and average single cell firing rate are specified, from
 which the appropriate number of spikes (i.e., active cells) per cycle is
 derived. 
 
 set prob_conn=0 for Nin independent poisson sources to each target cell
 set prob_conn=1 for the same Nin sources to all target cells
 given 0&lt;prob_conn&lt;1: each target cell receives (prob_conn*Nin) random
                      inputs from the same pool of input sources
 
 set f=0 for homogeneous Poisson process
 set f&gt;0 for rhythmic population spiking with synchrony-defining width and
         within-cycle rate-modulation specified by ac_type
 
 cell_FR: single-cell average input spike rate [spks/sec]
 
 % Example:
 Nin=10; Nout=10; p=.6; f=5; FR=5; w=10; T=0:.01:1000; tau=2; kick=1;
 sext=getPopRhythmGating(Nin,Nout,p,FR,f,w,T,0,inf,tau,kick);
 ds.plotData(sext)
 figure
 subplot(2,1,1); plot(T,sum(sext,2)); xlabel('t'); ylabel('total input from source rhythm')
 subplot(2,1,2); plot(T,sext); xlabel('t'); ylabel('inputs to each target cell');</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="nonhomPoissonGeneratorSpikeTimes.html" class="code" title="function S = nonhomPoissonGeneratorSpikeTimes(S_ini,rate,tau,kick,N,interval,dt)">nonhomPoissonGeneratorSpikeTimes</a>	</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
</ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="#_sub1" class="code">function spiking=ConstrainSpikeCount(spiking,tstart,t,width,num_spikes)</a></li><li><a href="#_sub2" class="code">function S = nonhomPoissonGeneratorSpikeTimes(S_ini,Ptot,tau,kick,num_targets,nt,dt)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [sext,tstart,Pinputs,Psource,conn,T,lambda]=getPopRhythmGating(num_sources,num_targets,prob_conn,cell_FR,pop_freq,width,T,onset,offset,tau_syn,kick,seed,mask,ac_type)</a>
0002 <span class="comment">% function [sext,tstart,Pinputs,Psource,conn,T]=getPopRhythmGating(num_sources,num_targets,prob_conn,cell_FR,pop_freq,width,T,onset,offset,tau_syn,kick,seed,mask,ac_type)</span>
0003 <span class="comment">% Purpose:</span>
0004 <span class="comment">% generates sparse population rhythmic input for a target network with</span>
0005 <span class="comment">% probabilistic input connectivity.</span>
0006 <span class="comment">% network frequency and average single cell firing rate are specified, from</span>
0007 <span class="comment">% which the appropriate number of spikes (i.e., active cells) per cycle is</span>
0008 <span class="comment">% derived.</span>
0009 <span class="comment">%</span>
0010 <span class="comment">% set prob_conn=0 for Nin independent poisson sources to each target cell</span>
0011 <span class="comment">% set prob_conn=1 for the same Nin sources to all target cells</span>
0012 <span class="comment">% given 0&lt;prob_conn&lt;1: each target cell receives (prob_conn*Nin) random</span>
0013 <span class="comment">%                      inputs from the same pool of input sources</span>
0014 <span class="comment">%</span>
0015 <span class="comment">% set f=0 for homogeneous Poisson process</span>
0016 <span class="comment">% set f&gt;0 for rhythmic population spiking with synchrony-defining width and</span>
0017 <span class="comment">%         within-cycle rate-modulation specified by ac_type</span>
0018 <span class="comment">%</span>
0019 <span class="comment">% cell_FR: single-cell average input spike rate [spks/sec]</span>
0020 <span class="comment">%</span>
0021 <span class="comment">% % Example:</span>
0022 <span class="comment">% Nin=10; Nout=10; p=.6; f=5; FR=5; w=10; T=0:.01:1000; tau=2; kick=1;</span>
0023 <span class="comment">% sext=getPopRhythmGating(Nin,Nout,p,FR,f,w,T,0,inf,tau,kick);</span>
0024 <span class="comment">% ds.plotData(sext)</span>
0025 <span class="comment">% figure</span>
0026 <span class="comment">% subplot(2,1,1); plot(T,sum(sext,2)); xlabel('t'); ylabel('total input from source rhythm')</span>
0027 <span class="comment">% subplot(2,1,2); plot(T,sext); xlabel('t'); ylabel('inputs to each target cell');</span>
0028 
0029 <span class="keyword">if</span> nargin&lt;1, num_sources=10; <span class="keyword">end</span>
0030 <span class="keyword">if</span> nargin&lt;2, num_targets=10; <span class="keyword">end</span>
0031 <span class="keyword">if</span> nargin&lt;3, prob_conn=.6; <span class="keyword">end</span>
0032 <span class="keyword">if</span> nargin&lt;4, cell_FR=10; <span class="keyword">end</span>
0033 <span class="keyword">if</span> nargin&lt;5, pop_freq=10; <span class="keyword">end</span>
0034 <span class="keyword">if</span> nargin&lt;6, width=10; <span class="keyword">end</span>
0035 <span class="keyword">if</span> nargin&lt;7, T=0:.01:1000; <span class="keyword">end</span>              <span class="comment">% [ms]</span>
0036 <span class="keyword">if</span> nargin&lt;8, onset=0; <span class="keyword">end</span>                    <span class="comment">% [ms]</span>
0037 <span class="keyword">if</span> nargin&lt;9, offset=inf; <span class="keyword">end</span>                 <span class="comment">% [ms]</span>
0038 <span class="keyword">if</span> nargin&lt;10, tau_syn=2; <span class="keyword">end</span>                 <span class="comment">% [ms]</span>
0039 <span class="keyword">if</span> nargin&lt;11, kick=1; <span class="keyword">end</span>                     <span class="comment">% [uA/cm2]</span>
0040 <span class="keyword">if</span> nargin&lt;12 || isempty(seed), seed=0; <span class="keyword">end</span> <span class="comment">% rng('shuffle'); seed=getfield(rng,'Seed');</span>
0041 <span class="keyword">if</span> nargin&lt;13 || isempty(mask), mask=ones(1,num_targets); <span class="keyword">end</span>
0042 <span class="keyword">if</span> nargin&lt;14 || isempty(ac_type), ac_type=<span class="string">'''step'''</span>; <span class="keyword">end</span> <span class="comment">% {'step','sine','gaus'}</span>
0043 <span class="comment">% num_sources=10;   % # of simulated inputs</span>
0044 <span class="comment">% num_targets=10;   % # of model cells in target population</span>
0045 <span class="comment">% prob_conn=.2;     % probability that source i connects to target cell j</span>
0046 <span class="comment">% width=10;         % ms, width of burst (i.e., input spike synchrony) (default: 10% of sim or cycle)</span>
0047 <span class="comment">% pop_freq=10;      % Hz, modulation frequency</span>
0048 <span class="comment">% cell_FR=10;       % Hz, avg spikes per sec per cell</span>
0049 <span class="comment">% mask=ones(1,num_targets); % mask to select which targets receive inputs</span>
0050 <span class="comment">% kick=1;           % uA/cm2, conductance kick per spike</span>
0051 <span class="comment">% tau_syn=2;        % ms, synaptic time constant</span>
0052 <span class="comment">% T=0:.01:1000;     % ms, time vector</span>
0053 <span class="comment">% onset=0;</span>
0054 <span class="comment">% offset=inf;</span>
0055 
0056 <span class="comment">% convert units to Hz and sec</span>
0057 onset=onset/1000;
0058 offset=offset/1000;
0059 dt=(T(2)-T(1))/1000;  <span class="comment">% sec, fixed integration time step</span>
0060 tdur=T(end)/1000;     <span class="comment">% sec, duration of simulation</span>
0061 t=0:dt:tdur;          <span class="comment">% sec, time vector</span>
0062 nt=length(t);
0063 cell_FR_dc=0; <span class="comment">% dummy</span>
0064 
0065 <span class="comment">% construct input connectivity kernel [{0,1}] [sources x targets]</span>
0066 <span class="comment">% note: every target cell has exactly (num_sources*prob_conn) inputs</span>
0067 conn=getPrConn(num_sources,num_targets,prob_conn,seed)&gt;0; <span class="comment">% *(prob_conn*num_sources)</span>
0068 
0069 <span class="keyword">if</span> pop_freq==0 <span class="comment">% homogeneous Poisson process</span>
0070   <span class="comment">% the entire simulation is one &quot;cycle&quot;</span>
0071   tstart=0;
0072   width=inf;
0073   <span class="comment">% establish duration of spiking interval</span>
0074   <span class="keyword">if</span> ~isinf(offset)
0075     tsdur=offset-onset;
0076   <span class="keyword">else</span>
0077     tsdur=t(end)-onset;
0078   <span class="keyword">end</span>
0079   <span class="keyword">if</span> tsdur&lt;0 <span class="comment">% account for unlikely case where onset is set to inf</span>
0080     tsdur=0;
0081   <span class="keyword">end</span>
0082   <span class="comment">% # spikes across all cells and time</span>
0083   num_spikes=cell_FR*num_sources*tsdur;
0084   <span class="comment">% homogeneous Poisson rate</span>
0085   lambda_=(cell_FR*num_sources)*ones(size(t));
0086 <span class="keyword">else</span> <span class="comment">% rhythmic bursts of nonhomogeneous Poisson process</span>
0087   <span class="comment">% # spikes per burst across all cells</span>
0088   num_spikes=cell_FR*num_sources/pop_freq;
0089   <span class="comment">% Construct time-varying lambda</span>
0090   <span class="comment">% calculate amplitude of ac component necessary to achieve desired num_spikes per burst</span>
0091   <span class="keyword">switch</span> ac_type
0092     <span class="keyword">case</span> {<span class="string">'sin'</span>,<span class="string">'''sin'''</span>,<span class="string">'sine'</span>,<span class="string">'''sine'''</span>}
0093       width=width*2/1000;   <span class="comment">% sec, double to provide refractory burst half-cycle</span>
0094       ac=(num_spikes-cell_FR_dc*(width/2))*(pi/(width*dt))/100000;
0095       <span class="comment">% rate-modulation for one cycle</span>
0096       yburst=sin(2*pi*(0:dt:width)/width);  <span class="comment">% -1 to 1</span>
0097     <span class="keyword">case</span> {<span class="string">'step'</span>,<span class="string">'''step'''</span>}
0098       width=width/1000;
0099       ac=num_spikes/width;
0100       yburst=ones(1,length(0:dt:width));    <span class="comment">% all 1</span>
0101     <span class="keyword">case</span> {<span class="string">'gaussian'</span>,<span class="string">'''gaussian'''</span>,<span class="string">'gaus'</span>,<span class="string">'''gaus'''</span>,<span class="string">'norm'</span>,<span class="string">'''norm'''</span>}
0102       width=width/1000;
0103       n=4; <span class="comment">% number of sigmas in width</span>
0104       sigma=width/n;
0105       bounds=(n/2)*sigma;
0106       <span class="comment">% calculate integral of gaussian within bounds</span>
0107       <span class="comment">% analytically:</span>
0108       integral=((normcdf(bounds,0,sigma)-normcdf(-bounds,0,sigma))*(sigma*sqrt(2*pi)));
0109       <span class="comment">% numerically integrate gaussian</span>
0110   <span class="comment">%     f=@(X,MU,SIGMA)exp(-(X-MU).^2./(2*SIGMA^2));</span>
0111   <span class="comment">%     x=(-T(end):(T(2)-T(1)):T(end))/1000;</span>
0112   <span class="comment">%     tix=nearest(x,-bounds):nearest(x,bounds);</span>
0113   <span class="comment">%     integral=(dt*sum(f(x(tix),0,sigma)));</span>
0114   <span class="comment">%     yburst=f(-bounds:dt:bounds,0,sigma);</span>
0115       ac=num_spikes/integral;
0116       X=-bounds:dt:bounds;
0117       yburst=exp(-(X-0).^2./(2*sigma^2));   <span class="comment">% 0 to 1</span>
0118     <span class="keyword">otherwise</span>
0119       error(<span class="string">'select ac_type {''sine'',''step'',''gaus''}'</span>);
0120   <span class="keyword">end</span>
0121 
0122   <span class="comment">% burst start times</span>
0123   Tibi0=(1/pop_freq)-width; <span class="comment">% sec, time b/w end of one burst and beginning of the next</span>
0124   Tosc=width+Tibi0; <span class="comment">% time b/w start of one burst and start of the next (i.e., period of effective modulation frequency)</span>
0125   tstart_=0:Tosc:tdur; <span class="comment">% start times for each burst</span>
0126   tstart=tstart_(tstart_&lt;tdur);
0127   <span class="comment">% insert burst every interburst interval</span>
0128   yac=zeros(size(t));
0129   ydc=ones(size(t));
0130   <span class="keyword">for</span> i=1:length(tstart)
0131     ton=tstart(i);
0132     ind=nearest(t,ton):nearest(t,ton+width);
0133     yac(ind)=yburst(1:length(ind));
0134     <span class="comment">%ydc(ind)=1;</span>
0135   <span class="keyword">end</span>
0136   dc=cell_FR_dc*num_sources;
0137   DC=dc*ones(size(ydc));
0138   AC=ac*ones(size(yac));
0139   lambda_=max(AC.*yac+DC.*ydc,0);  <span class="comment">% kHz, nonhomogeneous poisson rate, 0 to (dc+ac)</span>
0140 <span class="keyword">end</span>
0141   
0142 <span class="comment">% limit spiking to [onset,offset]</span>
0143 <span class="keyword">if</span> onset&gt;0
0144   <span class="comment">% shift start of signal by translating the nonhomogeneous Poisson rate</span>
0145   lambda=zeros(size(lambda_));
0146   index=nearest(T/1000,onset);
0147   inds=index:length(lambda);
0148   lambda(inds)=lambda_(1:length(lambda)-index+1);
0149   <span class="comment">% shift cycle start times</span>
0150   tstart=tstart+onset;
0151 <span class="keyword">else</span>
0152   lambda=lambda_;
0153 <span class="keyword">end</span>
0154 lambda(t&gt;offset)=0;<span class="comment">%lambda(t&lt;onset|t&gt;offset)=0;</span>
0155 
0156 <span class="comment">% factor by which to increase rate to guarantee enough spikes per cycle (excess will be removed below)</span>
0157 SF=2;
0158 
0159 <span class="keyword">if</span> prob_conn==0
0160   <span class="comment">% construct one poisson process per target for the entire source population</span>
0161   Pinputs=zeros(nt,num_targets);
0162   Psource=zeros(nt,num_targets);
0163   <span class="keyword">for</span> i=1:num_targets
0164     all_spiking=poissrnd(SF*lambda*dt);  <span class="comment">% poisson process (2x to make sure we get at least num_spikes)</span>
0165     spiking=<a href="#_sub1" class="code" title="subfunction spiking=ConstrainSpikeCount(spiking,tstart,t,width,num_spikes)">ConstrainSpikeCount</a>(all_spiking,tstart,t,width,num_spikes);
0166     Pinputs(:,i)=mask(i)*spiking;
0167     Psource(:,i)=spiking;
0168   <span class="keyword">end</span>
0169 <span class="keyword">else</span>
0170   <span class="comment">% Construct source Poisson process where every cycle of source pop activity</span>
0171   <span class="comment">% produces exactly num_spikes AC-modulated input spikes distributed</span>
0172   <span class="comment">% randomly across all source cells</span>
0173   all_spiking=poissrnd(SF*lambda*dt);  <span class="comment">% poisson process (2x to make sure we get at least num_spikes)</span>
0174   spiking=<a href="#_sub1" class="code" title="subfunction spiking=ConstrainSpikeCount(spiking,tstart,t,width,num_spikes)">ConstrainSpikeCount</a>(all_spiking,tstart,t,width,num_spikes);
0175   Psource=zeros(nt,num_sources);
0176   <span class="comment">% --------------------------</span>
0177   <span class="comment">% distribute spikes randomly across sources</span>
0178   <span class="comment">% only allow &gt;1 spike if all cells already have a spike</span>
0179   <span class="comment">% loop over cycles</span>
0180   <span class="keyword">for</span> i=1:length(tstart)
0181     ton=tstart(i); <span class="comment">% start time for this burst</span>
0182     tind=nearest(t,ton):nearest(t,ton+width); <span class="comment">% indices for this burst</span>
0183     <span class="comment">% randomize source indices</span>
0184     sources=randperm(num_sources);
0185     cnt=1; <span class="comment">% source counter</span>
0186     <span class="comment">% select spike times in this cycle</span>
0187     spike_inds=tind(1)+find(spiking(tind))-1;
0188     <span class="comment">% loop over spike times</span>
0189     <span class="keyword">for</span> j=1:length(spike_inds)
0190       <span class="comment">% determine how many spikes at this time</span>
0191       nspikes=spiking(spike_inds(j));
0192       <span class="comment">% loop over spikes at this time</span>
0193       <span class="keyword">for</span> k=1:nspikes
0194         <span class="comment">% insert spike into the next random source cell</span>
0195         Psource(spike_inds(j),sources(cnt))=1;
0196         <span class="comment">% increment source counter</span>
0197         cnt=cnt+1;
0198         <span class="comment">% re-randomize source indices and counter if spikes have been added to all</span>
0199         <span class="keyword">if</span> cnt&gt;num_sources
0200           sources=randperm(num_sources);
0201           cnt=1;
0202         <span class="keyword">end</span>
0203       <span class="keyword">end</span>
0204     <span class="keyword">end</span>
0205   <span class="keyword">end</span>
0206   <span class="comment">% --------------------------</span>
0207 <span class="comment">%   spike_ind=find(spiking);</span>
0208 <span class="comment">%   for i=1:length(spike_ind)</span>
0209 <span class="comment">%     spiker=randperm(num_sources,1);</span>
0210 <span class="comment">%     Psource(spike_ind(i),spiker)=1;</span>
0211 <span class="comment">%   end</span>
0212   <span class="comment">% --------------------------</span>
0213   <span class="comment">% convert source activity into target-specific input spiking given probabilistic input connectivity</span>
0214   Pinputs=zeros(nt,num_targets);
0215   <span class="keyword">for</span> i=1:num_targets
0216     Pinputs(:,i)=mask(i)*sum(Psource(:,conn(:,i)),2);
0217   <span class="keyword">end</span>
0218 <span class="keyword">end</span>
0219 
0220 <span class="comment">% calculate gating</span>
0221 S_ini = zeros(1,num_targets);
0222 sext=<a href="nonhomPoissonGeneratorSpikeTimes.html" class="code" title="function S = nonhomPoissonGeneratorSpikeTimes(S_ini,rate,tau,kick,N,interval,dt)">nonhomPoissonGeneratorSpikeTimes</a>(S_ini',Pinputs',tau_syn,kick,num_targets,nt,dt*1000)';
0223 
0224 <span class="keyword">end</span>
0225 
0226 <a name="_sub1" href="#_subfunctions" class="code">function spiking=ConstrainSpikeCount(spiking,tstart,t,width,num_spikes)</a>
0227   <span class="comment">% constrain s.t. exactly num_spikes occur per cycle</span>
0228   <span class="keyword">for</span> k=1:length(tstart) <span class="comment">% loop over cycles</span>
0229     ton=tstart(k); <span class="comment">% start time for this burst</span>
0230     ind=nearest(t,ton):nearest(t,ton+width); <span class="comment">% indices for this burst</span>
0231     Pburst=spiking(ind);
0232     nspks=sum(Pburst(:));
0233     <span class="comment">% remove excess spikes uniformly, one at a time</span>
0234     <span class="keyword">for</span> j=1:(nspks-num_spikes)
0235       inds=find(Pburst&gt;0);
0236       sel=inds(randperm(length(inds),1)); <span class="comment">% select random spike to remove</span>
0237       <span class="comment">%sel=inds(randsample(length(inds),1)); % select random spike to remove</span>
0238       Pburst(sel)=Pburst(sel)-1; <span class="comment">% remove the spike from this burst</span>
0239     <span class="keyword">end</span>
0240     spiking(ind)=Pburst;
0241   <span class="keyword">end</span>
0242 <span class="keyword">end</span>
0243 
0244 <a name="_sub2" href="#_subfunctions" class="code">function S = nonhomPoissonGeneratorSpikeTimes(S_ini,Ptot,tau,kick,num_targets,nt,dt)</a>
0245 <span class="comment">% original function created by Salva Ardid</span>
0246 
0247   S = zeros(num_targets,nt);
0248   <span class="keyword">for</span> i=1:num_targets <span class="comment">% loop over targets</span>
0249     <span class="comment">% Determine number of events in each time bin</span>
0250     p = Ptot(i,:);<span class="comment">%poissrnd(max(rate(i,:),0)*dt);</span>
0251     <span class="comment">% Get the proper length for the events</span>
0252     l = sum(p); <span class="comment">% # of spikes to target i</span>
0253     timeevents = zeros(1,l+1);
0254     <span class="comment">% For each dt compute the event times</span>
0255     ix = find(p); <span class="comment">% p diff than 0</span>
0256     cum = cumsum([1 p(ix)]);
0257     adds = diff([0 ix-1]);
0258     timeevents(cum(1:end-1)) = adds;
0259     timeevents(cum(end):end) = inf; <span class="comment">% no more spikes after that</span>
0260     timeevents = cumsum(timeevents); <span class="comment">% in dt units</span>
0261     timeevents = dt*sort(timeevents+rand(size(timeevents)));<span class="comment">% in each dt unit, the spike can happen anytime, with uniform distribution</span>
0262 
0263     S_tmp = S_ini(i);
0264     spikeTimePointer = 1;
0265     nextSpikeTime = timeevents(spikeTimePointer);
0266 
0267     time = 0;
0268     <span class="keyword">for</span> t = 1:nt
0269       time = time + dt;
0270       decayTime = dt;
0271       indSpikeNow = (nextSpikeTime&lt;=time);
0272       <span class="keyword">while</span> indSpikeNow
0273         decayTime = dt + (nextSpikeTime - time);
0274         S_tmp = S_tmp.*exp(-decayTime/tau);
0275         S_tmp = S_tmp + kick;
0276         decayTime = time - nextSpikeTime;
0277 
0278         spikeTimePointer = spikeTimePointer+1;
0279         nextSpikeTime = timeevents(spikeTimePointer);
0280         indSpikeNow = (nextSpikeTime&lt;=time);
0281       <span class="keyword">end</span>
0282       S_tmp = S_tmp.*exp(-decayTime/tau);
0283       S(i,t) = S_tmp;
0284     <span class="keyword">end</span>
0285   <span class="keyword">end</span>
0286 <span class="keyword">end</span>
0287 
0288 <span class="comment">% Poisson-based spike bursts with variable spike synchrony</span>
0289 <span class="comment">% Bursts can occur periodically or with exponentially-distributed</span>
0290 <span class="comment">% interburst intervals. The number of spikes per burst can be controlled or</span>
0291 <span class="comment">% be specified by a fixed amplitude ac of rate modulation.</span>
0292 
0293 <span class="comment">% arguments:</span>
0294 <span class="comment">%   num_spikes: # of spikes per burst</span>
0295 <span class="comment">%   Nsources:</span>
0296 <span class="comment">%   Ntargets:</span>
0297 <span class="comment">%   dc: constant homogeneous Poisson dc offset [Hz]</span>
0298 <span class="comment">%   width: burst width (width) [sec]</span>
0299 <span class="comment">%   freq</span>
0300 
0301 <span class="comment">% f=0: use exponential IBIs (meanIBI,minIBI=width)</span>
0302 <span class="comment">% f&gt;0: set Tibi=(1/f)-width</span>
0303 <span class="comment">% width: burst width [ms]</span>
0304 <span class="comment">% num_spikes: # of spikes per burst (DC+AC components)</span>
0305 <span class="comment">% dc: constant offset [Hz]</span>
0306 
0307 <span class="comment">% tip: input is sinusoidal if (1/freq)=width</span>
0308 <span class="comment">% tip: set minIBI to max width used across simulations to get similar #</span>
0309 <span class="comment">%      bursts for different levels of spike synchrony</span>
0310 
0311 <span class="comment">% constraints:</span>
0312 <span class="comment">% 1. next burst cannot begin until the previous one completes</span>
0313 <span class="comment">%   f&gt;0: (1/freq) &gt;= width</span>
0314 <span class="comment">%   f=0: min(Tibi) &gt;= width, where Tibi~exp(IBImean)</span>
0315 <span class="comment">% 2. exactly num_spikes should occur in the ac component only (i.e., in addition to spontaneous background activity)</span></pre></div>
<hr><address>Generated on Fri 07-Apr-2017 20:01:20 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>