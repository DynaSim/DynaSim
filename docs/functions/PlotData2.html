<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of ds.plotData2</title>
  <meta name="keywords" content="ds.plotData2">
  <meta name="description" content="% handles=ds.plotData(data,'option',value)">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- menu.html functions -->
<h1>ds.plotData2
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>% handles=ds.plotData(data,'option',value)</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function [handles,xp]=ds.plotData2(data,varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment">% handles=ds.plotData(data,'option',value)
 Purpose: plot data in various ways depending on what data was provided
 and what options are defined. this function is wrapped by ds.plotWaveforms,
 PlotPower, ... to provide a single function for organizing and displaying
 data.
 Inputs:
   data: DynaSim data structure (see ds.checkData)
   Accepts the following name/value pairs:
     'plot_type' {'waveform' (default),'rastergram','rates','power'} - what to plot
     'population' - name of population to plot (default: 'all'); accepts
                    regexp strings
     'variable' - name of variable to plot for each population (default: state variable, X or V);
                      accepts regexp strings
     'varied1' - Indices of 1st varied model parameter to plot. If the parameter
                 is numeric, specify indices (e.g. 1:3 corresponds to 1st-3rd
                 varied values. If the parameter is a char array, uses
                 regular expressions. Instead of 'varied1', can also use
                 the actual parameter name (e.g. 'E_Iapp')
     'varied2' - As varied 1, for 2nd varied parameter
     ....
     'variedN' - As varied 1, for 2nd varied parameter
     'num_embedded_subplots' - maximum # of waveforms to overlay per plot
     'max_num_overlaid' - maximum # of waveforms to overlay per plot
     'do_mean' - {false, true} - Turn on/off averaging across all units
                 in a population
     'force_overlay' - {'none', 'populations' (default), 'variables', 'varied1' ... 'variedN'}
                       If there is only one cell in a population, this forces
                       ds.plotData2 to add other information to the overlay.
     'xlims' - [XMIN XMAX], x-axis limits (default: all data)
     'ylims' - [YMIN YMAX], y-axis limits (default: all data)
     'lock_axes' - {false, true}, locks abscissa and ordinate to be
                                  the same across all subplots
     'do_zoom' - {false, true} - Turn on zoom function in subplot_grid
     'yscale' {'linear','log','log10'}, whether to plot linear or log scale
     'visible' {'on','off'}
     NOTE: analysis options available depending on plot_type
       see see ds.calcFR options for plot_type 'rastergram' or 'rates'
       see ds.calcPower options for plot_type 'power'
 Outputs:
   handles: graphic handles to figures
 
 See also: <a href="ds.calcFR.html" class="code" title="function data = ds.calcFR(data,varargin)">ds.calcFR</a>, <a href="ds.calcPower.html" class="code" title="function data = ds.calcPower(data,varargin)">ds.calcPower</a>, <a href="ds.plotWaveforms.html" class="code" title="function ds.plotWaveforms(data,varargin)">ds.plotWaveforms</a>, <a href="ds.checkData.html" class="code" title="function data=ds.checkData(data)">ds.checkData</a>, <a href="ds.plotData.html" class="code" title="function handles = ds.plotData(data,varargin)">ds.plotData</a>, xPlt,
           nDDict</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="ds.xPlt.all2xPlt.html" class="code" title="function [xp,is_image] = ds.xPlt.all2xPlt(data)">ds.xPlt.all2xPlt</a>	</li><li><a href="ds.checkOptions.html" class="code" title="function [parms, params_unspecified ] = ds.checkOptions(options, options_schema, strict)">ds.checkOptions</a>	CHECKOPTIONS - organize key/value pairs in structure with default or user-supplied values according to a schema</li><li><a href="ds.importPlots.html" class="code" title="function [data,studyinfo] = ds.importPlots(file,varargin)">ds.importPlots</a>	IMPORTPLOTS - load info about saved images (generated by SimulateMode or ds.analyzeData) alongwith corresponding varied model components.</li><li><a href="ds.plotData2.html" class="code" title="function [handles,xp]=ds.plotData2(data,varargin)">ds.plotData2</a>	% handles=ds.plotData(data,'option',value)</li><li><a href="struct_addDef.html" class="code" title="function s = struct_addDef(s,fieldname,default_value)">struct_addDef</a>	STRUCT_ADDDEF - add fieldname to structure if it doesn't already exist</li><li><a href="../functions/supporting_ds.ds2xPlt/ds.xPlt.get_variables_from_meta.html" class="code" title="function varlabels = ds.xPlt.get_variables_from_meta(xp)">ds.xPlt.get_variables_from_meta</a>	</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="ds.plotData2.html" class="code" title="function [handles,xp]=ds.plotData2(data,varargin)">ds.plotData2</a>	% handles=ds.plotData(data,'option',value)</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="#_sub1" class="code">function_handles = {@xp_handles_newfig, @xp_subplot_grid,data_plothandle};</a></li><li><a href="#_sub2" class="code">function_args = {{figure_options},{subplot_options},{plot_options}};</a></li><li><a href="#_sub3" class="code">function_handles = {@xp_handles_newfig, @xp_subplot_grid,data_plothandle};</a></li><li><a href="#_sub4" class="code">function_args = {{figure_options},{subplot_options},{plot_options}};</a></li><li><a href="#_sub5" class="code">function_handles = {@xp_handles_newfig, @xp_subplot_grid, @xp_subplot_grid,data_plothandle};</a></li><li><a href="#_sub6" class="code">function_args = {{figure_options},{subplot_options2},{subplot_options},{plot_options}};</a></li><li><a href="#_sub7" class="code">function_handles = {@xp_handles_newfig, @xp_subplot_grid, @xp_subplot_grid,data_plothandle};</a></li><li><a href="#_sub8" class="code">function_args = {{figure_options},{subplot_options2},{subplot_options},{plot_options}};</a></li><li><a href="#_sub9" class="code">function_handles = function_handles(available_dims);</a></li><li><a href="#_sub10" class="code">function_args = function_args(available_dims);</a></li><li><a href="#_sub11" class="code">function var_out = getdefaultstatevar(xp)</a></li><li><a href="#_sub12" class="code">function [chosen_varied, options_varied ]= get_chosen_varied(varied_names,options_varied)</a></li><li><a href="#_sub13" class="code">function str_out = variedN_to_axisnames(str_in,ax_names_varied)</a></li><li><a href="#_sub14" class="code">function ax_ind_varied = findaxis_varied(xp)</a></li><li><a href="#_sub15" class="code">function dimensions = get_dimensions(ax_names,dims_per_function_handle)</a></li><li><a href="#_sub16" class="code">function xp2 = reduce_dims(xp2,maxNplotdims)</a></li><li><a href="#_sub17" class="code">function varied_names = only_varieds(xp)</a></li><li><a href="#_sub18" class="code">function varied_names = only_varieds_old_deleteme(all_names)</a></li><li><a href="#_sub19" class="code">function mydata_out = do_shift_lastdim (mydata,shift)</a></li><li><a href="#_sub20" class="code">function leg1 = setup_legends(xp2)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [handles,xp]=ds.plotData2(data,varargin)</a>
0002 <span class="comment">%% handles=ds.plotData(data,'option',value)</span>
0003 <span class="comment">% Purpose: plot data in various ways depending on what data was provided</span>
0004 <span class="comment">% and what options are defined. this function is wrapped by ds.plotWaveforms,</span>
0005 <span class="comment">% PlotPower, ... to provide a single function for organizing and displaying</span>
0006 <span class="comment">% data.</span>
0007 <span class="comment">% Inputs:</span>
0008 <span class="comment">%   data: DynaSim data structure (see ds.checkData)</span>
0009 <span class="comment">%   Accepts the following name/value pairs:</span>
0010 <span class="comment">%     'plot_type' {'waveform' (default),'rastergram','rates','power'} - what to plot</span>
0011 <span class="comment">%     'population' - name of population to plot (default: 'all'); accepts</span>
0012 <span class="comment">%                    regexp strings</span>
0013 <span class="comment">%     'variable' - name of variable to plot for each population (default: state variable, X or V);</span>
0014 <span class="comment">%                      accepts regexp strings</span>
0015 <span class="comment">%     'varied1' - Indices of 1st varied model parameter to plot. If the parameter</span>
0016 <span class="comment">%                 is numeric, specify indices (e.g. 1:3 corresponds to 1st-3rd</span>
0017 <span class="comment">%                 varied values. If the parameter is a char array, uses</span>
0018 <span class="comment">%                 regular expressions. Instead of 'varied1', can also use</span>
0019 <span class="comment">%                 the actual parameter name (e.g. 'E_Iapp')</span>
0020 <span class="comment">%     'varied2' - As varied 1, for 2nd varied parameter</span>
0021 <span class="comment">%     ....</span>
0022 <span class="comment">%     'variedN' - As varied 1, for 2nd varied parameter</span>
0023 <span class="comment">%     'num_embedded_subplots' - maximum # of waveforms to overlay per plot</span>
0024 <span class="comment">%     'max_num_overlaid' - maximum # of waveforms to overlay per plot</span>
0025 <span class="comment">%     'do_mean' - {false, true} - Turn on/off averaging across all units</span>
0026 <span class="comment">%                 in a population</span>
0027 <span class="comment">%     'force_overlay' - {'none', 'populations' (default), 'variables', 'varied1' ... 'variedN'}</span>
0028 <span class="comment">%                       If there is only one cell in a population, this forces</span>
0029 <span class="comment">%                       ds.plotData2 to add other information to the overlay.</span>
0030 <span class="comment">%     'xlims' - [XMIN XMAX], x-axis limits (default: all data)</span>
0031 <span class="comment">%     'ylims' - [YMIN YMAX], y-axis limits (default: all data)</span>
0032 <span class="comment">%     'lock_axes' - {false, true}, locks abscissa and ordinate to be</span>
0033 <span class="comment">%                                  the same across all subplots</span>
0034 <span class="comment">%     'do_zoom' - {false, true} - Turn on zoom function in subplot_grid</span>
0035 <span class="comment">%     'yscale' {'linear','log','log10'}, whether to plot linear or log scale</span>
0036 <span class="comment">%     'visible' {'on','off'}</span>
0037 <span class="comment">%     NOTE: analysis options available depending on plot_type</span>
0038 <span class="comment">%       see see ds.calcFR options for plot_type 'rastergram' or 'rates'</span>
0039 <span class="comment">%       see ds.calcPower options for plot_type 'power'</span>
0040 <span class="comment">% Outputs:</span>
0041 <span class="comment">%   handles: graphic handles to figures</span>
0042 <span class="comment">%</span>
0043 <span class="comment">% See also: ds.calcFR, ds.calcPower, ds.plotWaveforms, ds.checkData, ds.plotData, xPlt,</span>
0044 <span class="comment">%           nDDict</span>
0045 
0046 <span class="comment">%% Set Master parameters</span>
0047   
0048 <span class="comment">% Flag for returning error if the user specifies name/value pairs that are not in the</span>
0049 <span class="comment">% ds.checkOptions list</span>
0050 strict_mode = 0;        <span class="comment">% Should be set to zero for this to work within simulate model</span>
0051 
0052 <span class="comment">%% Convert data input to appropriate form</span>
0053 
0054 <span class="comment">% If data is path to studyinfo...</span>
0055 <span class="keyword">if</span> ischar(data)
0056     study_dir = data;
0057     
0058     <span class="comment">% Import plot files</span>
0059     data_img = <a href="ds.importPlots.html" class="code" title="function [data,studyinfo] = ds.importPlots(file,varargin)">ds.importPlots</a>(study_dir);
0060     
0061     handles = <a href="ds.plotData2.html" class="code" title="function [handles,xp]=ds.plotData2(data,varargin)">ds.plotData2</a>(data_img,varargin{:});
0062     <span class="keyword">return</span>;
0063 <span class="keyword">end</span>
0064 
0065 <span class="comment">% Convert the incoming DynaSim data structure to an xPlt object</span>
0066 <span class="keyword">if</span> ~isa(data,<span class="string">'xPlt'</span>)
0067     [xp,is_image] = <a href="ds.xPlt.all2xPlt.html" class="code" title="function [xp,is_image] = ds.xPlt.all2xPlt(data)">ds.xPlt.all2xPlt</a>(data);
0068 <span class="keyword">end</span>
0069 
0070 <span class="comment">%% Convert varargin to appropriate forms</span>
0071 <span class="comment">% Find out names of varied variables</span>
0072 varied_names = <a href="#_sub17" class="code" title="subfunction varied_names = only_varieds(xp)">only_varieds</a>(xp);  <span class="comment">% Returns only the names of the varied variables</span>
0073 
0074 <span class="comment">% Convert 'varied1'...'variedN' values in varargin to the names of the</span>
0075 <span class="comment">% actual varied parameters</span>
0076 myargin = varargin;
0077 <span class="keyword">for</span> i = 1:length(myargin)
0078     <span class="comment">% Char entries</span>
0079     <span class="keyword">if</span> ischar(myargin{i})
0080         myargin{i} = <a href="#_sub13" class="code" title="subfunction str_out = variedN_to_axisnames(str_in,ax_names_varied)">variedN_to_axisnames</a>(myargin{i},varied_names);
0081     <span class="keyword">end</span>
0082     
0083     <span class="comment">% Nested char entries within cell array entries</span>
0084     <span class="keyword">if</span> iscell(myargin{i})
0085         <span class="keyword">for</span> j = 1:length(myargin{i})
0086             <span class="keyword">if</span> ischar(myargin{i}{j})
0087                 myargin{i}{j} = <a href="#_sub13" class="code" title="subfunction str_out = variedN_to_axisnames(str_in,ax_names_varied)">variedN_to_axisnames</a>(myargin{i}{j},varied_names);
0088             <span class="keyword">end</span>
0089         <span class="keyword">end</span>
0090     <span class="keyword">end</span>
0091 <span class="keyword">end</span>
0092 
0093 <span class="comment">% %% Add dummy axes as needed. Having these greatly simplifies the code below.</span>
0094 <span class="comment">% if isempty(xp.findaxis('populations'))</span>
0095 <span class="comment">%     Na=length(xp.axis);</span>
0096 <span class="comment">%     xp.axis(Na+1).name = 'populations';</span>
0097 <span class="comment">%     xp.axis(Na+1).values = 'Pop1';</span>
0098 <span class="comment">% end</span>
0099 <span class="comment">%</span>
0100 <span class="comment">% if isempty(xp.findaxis('variables'))</span>
0101 <span class="comment">%     Na=length(xp.axis);</span>
0102 <span class="comment">%     xp.axis(Na+1).name = 'variables';</span>
0103 <span class="comment">%     xp.axis(Na+1).values = 'X';</span>
0104 <span class="comment">% end</span>
0105 <span class="comment">%</span>
0106 <span class="comment">% if isempty(findaxis_varied(xp))  % If no varied axes</span>
0107 <span class="comment">%     Na=length(xp.axis);</span>
0108 <span class="comment">%     xp.axis(Na+1).name = 'Varied1';</span>
0109 <span class="comment">%     xp.axis(Na+1).values = 1;</span>
0110 <span class="comment">% end</span>
0111 
0112 <span class="comment">%% Parse varargin and set up defaults</span>
0113 [options, options_extras0] = <a href="ds.checkOptions.html" class="code" title="function [parms, params_unspecified ] = ds.checkOptions(options, options_schema, strict)">ds.checkOptions</a>(myargin,{<span class="keyword">...</span>
0114   <span class="string">'population'</span>,[],[],<span class="keyword">...</span><span class="comment">        </span>
0115   <span class="string">'variable'</span>,[],[],<span class="keyword">...</span><span class="comment">        </span>
0116   <span class="string">'num_embedded_subplots'</span>,2,{1,2,3,4},<span class="keyword">...</span>
0117   <span class="string">'max_num_overlaid'</span>,50,[],<span class="keyword">...</span>
0118   <span class="string">'do_mean'</span>,false,[false true],<span class="keyword">...</span>
0119   <span class="string">'force_overlay'</span>,[],[],<span class="keyword">...</span>
0120   <span class="string">'do_overlay_shift'</span>,false,[false true],<span class="keyword">...</span>
0121   <span class="string">'overlay_shift_val'</span>,[],[],<span class="keyword">...</span>
0122   <span class="string">'do_zscore'</span>,[false],[false true],<span class="keyword">...</span>
0123   <span class="string">'plot_type'</span>,<span class="string">'waveform'</span>,{<span class="string">'waveform'</span>,<span class="string">'imagesc'</span>,<span class="string">'rastergram'</span>,<span class="string">'raster'</span>,<span class="string">'power'</span>,<span class="string">'heatmapFR'</span>,<span class="string">'heatmap_sortedFR'</span>,<span class="string">'meanFR'</span>,<span class="string">'meanFRdens'</span>},<span class="keyword">...</span>
0124   <span class="string">'xlims'</span>,[],[],<span class="keyword">...</span>
0125   <span class="string">'ylims'</span>,[],[],<span class="keyword">...</span>
0126   <span class="string">'zlims'</span>,[],[],<span class="keyword">...</span>
0127   <span class="string">'figwidth'</span>,[1],[],<span class="keyword">...</span>
0128   <span class="string">'figheight'</span>,[1],[],<span class="keyword">...</span>
0129   <span class="string">'crop_range'</span>,[],[],<span class="keyword">...</span>
0130   <span class="string">'lock_axes'</span>,true,[false true],<span class="keyword">...</span>
0131   <span class="string">'saved_fignum'</span>,[1],[],<span class="keyword">...</span>
0132   <span class="string">'max_num_newfigs'</span>,[5],[],<span class="keyword">...</span>
0133   <span class="string">'plot_options'</span>,struct,[],<span class="keyword">...</span>
0134   <span class="string">'subplot_options'</span>,struct,[],<span class="keyword">...</span>
0135   <span class="string">'figure_options'</span>,struct,[],<span class="keyword">...</span>
0136   <span class="string">'do_zoom'</span>,false,[false true],<span class="keyword">...</span>
0137   <span class="string">'yscale'</span>,<span class="string">'linear'</span>,{<span class="string">'linear'</span>,<span class="string">'log'</span>,<span class="string">'log10'</span>,<span class="string">'log2'</span>},<span class="keyword">...</span>
0138   <span class="string">'visible'</span>,<span class="string">'on'</span>,{<span class="string">'on'</span>,<span class="string">'off'</span>},<span class="keyword">...</span>
0139   <span class="string">'show_colorbar'</span>,false,[false true],<span class="keyword">...</span>
0140   <span class="string">'save_figures'</span>,false,[false true],<span class="keyword">...</span>
0141   <span class="string">'save_figname_path'</span>,[],[],<span class="keyword">...</span>
0142   <span class="string">'supersize_me'</span>,false,[false true],<span class="keyword">...</span>
0143   <span class="string">'Ndims_pass_to_data'</span>,1,[],<span class="keyword">...</span>
0144   <span class="string">'dim_stacking'</span>,[],[],<span class="keyword">...</span>
0145   },false);
0146 handles=[];
0147 
0148 
0149 
0150 
0151 <span class="comment">% Options overwrite</span>
0152 <span class="keyword">if</span> is_image
0153     options.force_overlay = <span class="string">'none'</span>;
0154 <span class="keyword">end</span>
0155 
0156 <span class="comment">% Clause to fix things incase user sets force_overlay to zero!</span>
0157 <span class="keyword">if</span> isnumeric(options.force_overlay) &amp;&amp; ~isempty(options.force_overlay)
0158     warning(<span class="string">'force overlay should be either &quot;none&quot; or the name the name of an axis {populations, variables, varied1, ... variedN}'</span>);
0159     <span class="keyword">if</span> options.force_overlay == 0
0160         options.force_overlay = <span class="string">'none'</span>;
0161     <span class="keyword">end</span>
0162 <span class="keyword">end</span>
0163 
0164 <span class="comment">% Pull out fields from options struct</span>
0165 plot_type = options.plot_type;
0166 plot_options = options.plot_options;
0167 subplot_options = options.subplot_options;
0168 figure_options = options.figure_options;
0169 num_embedded_subplots = options.num_embedded_subplots;
0170 do_mean = options.do_mean;
0171 force_overlay = options.force_overlay;
0172 crop_range = options.crop_range;
0173 lock_axes = options.lock_axes;
0174 Ndims_pass_to_data = options.Ndims_pass_to_data;
0175 
0176 <span class="comment">% Add default options to structures</span>
0177 <span class="comment">% Plot_options</span>
0178 <span class="comment">% Used when running xp_matrix_advancedplot3D</span>
0179     plot_options = <a href="struct_addDef.html" class="code" title="function s = struct_addDef(s,fieldname,default_value)">struct_addDef</a>(plot_options,<span class="string">'ylims'</span>,options.ylims);
0180     plot_options = <a href="struct_addDef.html" class="code" title="function s = struct_addDef(s,fieldname,default_value)">struct_addDef</a>(plot_options,<span class="string">'xlims'</span>,options.xlims);
0181     plot_options = <a href="struct_addDef.html" class="code" title="function s = struct_addDef(s,fieldname,default_value)">struct_addDef</a>(plot_options,<span class="string">'zlims'</span>,options.zlims);
0182 <span class="comment">% Used when running xp_plotimage</span>
0183     plot_options = <a href="struct_addDef.html" class="code" title="function s = struct_addDef(s,fieldname,default_value)">struct_addDef</a>(plot_options,<span class="string">'saved_fignum'</span>,options.saved_fignum);
0184 <span class="comment">% Used when running xp_ds.plotData or xp_ds.plotFR2</span>
0185     plot_options = <a href="struct_addDef.html" class="code" title="function s = struct_addDef(s,fieldname,default_value)">struct_addDef</a>(plot_options,<span class="string">'args'</span>,{});
0186 
0187 <span class="comment">% Subplot_options</span>
0188 subplot_options = <a href="struct_addDef.html" class="code" title="function s = struct_addDef(s,fieldname,default_value)">struct_addDef</a>(subplot_options,<span class="string">'subplotzoom_enabled'</span>,options.do_zoom);
0189 subplot_options = <a href="struct_addDef.html" class="code" title="function s = struct_addDef(s,fieldname,default_value)">struct_addDef</a>(subplot_options,<span class="string">'force_rowvect'</span>,true);
0190 
0191 <span class="comment">% Figure options</span>
0192 figure_options = <a href="struct_addDef.html" class="code" title="function s = struct_addDef(s,fieldname,default_value)">struct_addDef</a>(figure_options,<span class="string">'visible'</span>,options.visible);
0193 figure_options = <a href="struct_addDef.html" class="code" title="function s = struct_addDef(s,fieldname,default_value)">struct_addDef</a>(figure_options,<span class="string">'save_figures'</span>,options.save_figures);
0194 figure_options = <a href="struct_addDef.html" class="code" title="function s = struct_addDef(s,fieldname,default_value)">struct_addDef</a>(figure_options,<span class="string">'save_figname_path'</span>,options.save_figname_path);
0195 figure_options = <a href="struct_addDef.html" class="code" title="function s = struct_addDef(s,fieldname,default_value)">struct_addDef</a>(figure_options,<span class="string">'supersize_me'</span>,options.supersize_me);
0196 figure_options = <a href="struct_addDef.html" class="code" title="function s = struct_addDef(s,fieldname,default_value)">struct_addDef</a>(figure_options,<span class="string">'max_num_newfigs'</span>,options.max_num_newfigs);
0197 figure_options = <a href="struct_addDef.html" class="code" title="function s = struct_addDef(s,fieldname,default_value)">struct_addDef</a>(figure_options,<span class="string">'figwidth'</span>,options.figwidth);
0198 figure_options = <a href="struct_addDef.html" class="code" title="function s = struct_addDef(s,fieldname,default_value)">struct_addDef</a>(figure_options,<span class="string">'figheight'</span>,options.figheight);
0199 
0200 
0201 
0202 
0203 <span class="comment">%% Pre-process raw data contained in xp.data (mean + downsample)</span>
0204 <span class="comment">% % Note: these options don't work if data are images</span>
0205 <span class="comment">% Apply max overlaid</span>
0206 MTPP = options.max_num_overlaid; <span class="comment">% max traces per plot</span>
0207 <span class="keyword">if</span> any(strcmp(options.plot_type,{<span class="string">'waveform'</span>,<span class="string">'power'</span>})) &amp;&amp; all(cellfun(@isnumeric,xp.data(:))) &amp;&amp; ~do_mean &amp;&amp; ~is_image
0208     mydata = xp.data;
0209     mydata2 = cell(size(mydata));
0210     <span class="keyword">for</span> i = 1:numel(mydata)
0211         <span class="keyword">if</span> ~isempty(mydata{i})
0212             mydata2{i} = mydata{i}(:,1:min(size(mydata{i},2),MTPP));
0213         <span class="keyword">end</span>
0214     <span class="keyword">end</span>
0215     
0216     xp.data = mydata2;
0217     clear mydata mydata2
0218     
0219     <span class="comment">% Update cell numbers metadata</span>
0220     cell_names = [1:max(cellfun(@(x) size(x,2),xp.data(:)))];
0221     cell_names_str = cellfunu(@(s) [<span class="string">'Cell '</span> num2str(s)], num2cell(cell_names));
0222     xp.meta.datainfo(2).values = cell_names_str;
0223 <span class="keyword">end</span>
0224 
0225 
0226 <span class="comment">% Average across cells if necessary</span>
0227 <span class="keyword">if</span> do_mean &amp;&amp; ~is_image
0228     mydata = xp.data;
0229     mydata = cellfun(@(x) mean(x,2), mydata,<span class="string">'UniformOutput'</span>,0);
0230     xp.data = mydata;
0231     xp.meta.datainfo(2).values = {<span class="string">'&lt;Cells&gt;'</span>};
0232 <span class="keyword">end</span>
0233 
0234 <span class="comment">%% Arrange dimensions of xp in appropriate order</span>
0235 <span class="comment">% % Should be variables x populations x varied1 x ... x variedN</span>
0236 
0237 <span class="comment">% Axis indices of populations</span>
0238 ax_ind_var = xp.findaxis(<span class="string">'variables'</span>);
0239 ax_ind_pop = xp.findaxis(<span class="string">'population'</span>);
0240 ax_ind_varied = <a href="#_sub14" class="code" title="subfunction ax_ind_varied = findaxis_varied(xp)">findaxis_varied</a>(xp);
0241 
0242 <span class="comment">% Permute to put varied variables last</span>
0243 myorder = [ax_ind_var, ax_ind_pop, ax_ind_varied(:)'];
0244 <span class="keyword">if</span> length(myorder) &gt; 1
0245     xp = permute(xp,myorder);
0246 <span class="keyword">end</span>
0247 
0248 <span class="comment">%% Identify user selections for populations, variables, etc., and convert xp to xp2</span>
0249 <span class="comment">% %  (xp2 contains only user selections)</span>
0250 <span class="comment">% User selection for populations</span>
0251 chosen_pop = options.population;
0252 <span class="keyword">if</span> isempty(chosen_pop)
0253     chosen_pop = <span class="string">':'</span>;
0254 <span class="keyword">end</span>
0255 
0256 <span class="comment">% User selection for state variables</span>
0257 chosen_vars = options.variable;
0258 <span class="keyword">if</span> isempty(chosen_vars)
0259     chosen_vars = <a href="#_sub11" class="code" title="subfunction var_out = getdefaultstatevar(xp)">getdefaultstatevar</a>(xp);
0260 <span class="keyword">end</span>
0261 
0262 <span class="comment">% User selection for varied parameters</span>
0263 options_extras = options_extras0;
0264 [chosen_varied , options_extras ]= <a href="#_sub12" class="code" title="subfunction [chosen_varied, options_varied ]= get_chosen_varied(varied_names,options_varied)">get_chosen_varied</a>(varied_names,options_extras);
0265 
0266 <span class="comment">% If any options are still leftover, these are extraneous. Report an error</span>
0267 leftover_fields = fieldnames(options_extras);
0268 <span class="keyword">if</span> ~isempty(leftover_fields) &amp;&amp; strict_mode
0269     error(<span class="string">'The following unrecogized name/value pairs were passed in: %s'</span>, sprintf(<span class="string">'%s '</span>,leftover_fields{:}));
0270 <span class="keyword">end</span>
0271 
0272 <span class="comment">% Convert any &quot;all&quot; strings in chosen_varied to colon operators</span>
0273 inds = cellfun(@ischar,chosen_varied);
0274 chosen_varied(inds) = cellfun(@(s) strrep(s,<span class="string">'all'</span>,<span class="string">':'</span>),chosen_varied(inds),<span class="string">'UniformOutput'</span>,0);
0275 <span class="keyword">if</span> strcmp(chosen_vars,<span class="string">'all'</span>); chosen_vars = <span class="string">':'</span>; <span class="keyword">end</span>
0276 <span class="keyword">if</span> strcmp(chosen_pop,<span class="string">'all'</span>); chosen_pop = <span class="string">':'</span>; <span class="keyword">end</span>
0277 
0278 <span class="comment">% Select out chosen data</span>
0279 chosen_all = {};                     
0280 <span class="keyword">if</span> ~isempty(ax_ind_varied); chosen_all = [chosen_varied,chosen_all]; <span class="keyword">end</span>
0281 <span class="keyword">if</span> ~isempty(xp.findaxis(<span class="string">'populations'</span>)); chosen_all = [chosen_pop,chosen_all]; <span class="keyword">end</span>
0282 <span class="keyword">if</span> ~isempty(xp.findaxis(<span class="string">'variables'</span>)); chosen_all = [chosen_vars,chosen_all]; <span class="keyword">end</span>
0283 <span class="comment">%xp2 = xp(chosen_vars,chosen_pop,chosen_varied{:});</span>
0284 <span class="keyword">if</span> ndims(xp) == 2 &amp;&amp; ~isempty(strfind(xp.axis(2).name,<span class="string">'Dim'</span>)) &amp;&amp; length(chosen_all) == 1
0285     chosen_all = [chosen_all {<span class="string">':'</span>}];        <span class="comment">% If xp is a column vector and only 1 varied entry present, fill out chosen_all to be size 2.</span>
0286 <span class="keyword">end</span>
0287 xp2 = xp(chosen_all{:});
0288 
0289 <span class="comment">%% Set up force overlay</span>
0290 <span class="comment">% Assign default value to force_overlay</span>
0291 <span class="keyword">if</span> isempty(force_overlay) 
0292     <span class="keyword">if</span> length(xp2.meta.datainfo(2).values) &lt;= 1 &amp;&amp; ~isempty(xp2.findaxis(<span class="string">'populations'</span>))
0293         force_overlay = <span class="string">'populations'</span>;
0294     <span class="keyword">else</span>
0295         force_overlay = <span class="string">'none'</span>;
0296     <span class="keyword">end</span>
0297 <span class="keyword">end</span>
0298 
0299 <span class="keyword">if</span> ~strcmpi(force_overlay,<span class="string">'none'</span>)
0300     ax_num = xp2.findaxis(force_overlay);
0301     <span class="keyword">if</span> length(ax_num) &gt; 1; error(<span class="string">'force_overlay: Ambiguous axis specified. Can only pack at most 1 axis'</span>);
0302     <span class="keyword">elseif</span> isempty(ax_num)
0303         error(<span class="string">'force_overlay: Cannot find requested axis'</span>);
0304     <span class="keyword">end</span>
0305     
0306     <span class="comment">% Save variables associated with this axis</span>
0307     packed_vars = xp2.axis(ax_num).values;
0308     packed_name = xp2.axis(ax_num).name;
0309     
0310     <span class="comment">% Add &lt;average&gt; symbols if necessary to packed_vars</span>
0311     cellnames = xp2.meta.datainfo(2).values;
0312     temp = cellfun(@isempty,strfind(cellnames,<span class="string">'&lt;'</span>));    <span class="comment">% Check if originals were averages!</span>
0313     <span class="keyword">if</span> any(~temp)
0314         <span class="keyword">if</span> isnumeric(packed_vars); packed_vars = cellfunu(@(s) [strrep(packed_name,<span class="string">'_'</span>,<span class="string">' '</span>) <span class="string">' '</span> num2str(s)],num2cell(packed_vars)); <span class="keyword">end</span>
0315         packed_vars = cellfunu(@(s) [<span class="string">'&lt;'</span> s <span class="string">'&gt;'</span>], packed_vars);
0316     <span class="keyword">end</span>
0317     
0318     <span class="comment">% Add this new info to datainfo</span>
0319     <span class="comment">% If there is still more than 1 cell present, bump this data down a</span>
0320     <span class="comment">% dimension.</span>
0321     only_one_cell = length(xp2.meta.datainfo(2).values) == 1;
0322     <span class="keyword">if</span> ~only_one_cell
0323         xp2.meta.datainfo(end+1) = xp2.meta.datainfo(end);
0324     <span class="keyword">end</span>
0325     xp2.meta.datainfo(end).name = packed_name;
0326     xp2.meta.datainfo(end).values = packed_vars(:)';
0327     
0328     
0329     <span class="comment">% Pack the dimension into the first empty dimension</span>
0330     xp2 = xp2.packDim(force_overlay);
0331     <span class="keyword">if</span> only_one_cell
0332         xp2.data = cellfunu(@squeeze,xp2.data);
0333         <span class="comment">% Note: This can cause some errors when unpacking the data later. The</span>
0334         <span class="comment">% specific scenario is when running in rastergram mode &amp; having only</span>
0335         <span class="comment">% 1 cell. For example,</span>
0336         <span class="comment">% close all; d = data_mat_pops; ds.plotData2(d,'plot_type','rastergram','do_mean',1);</span>
0337     <span class="keyword">end</span>
0338 
0339 <span class="keyword">end</span>
0340 
0341 <span class="comment">%% Set up do z-score &amp; overlay shift</span>
0342 <span class="keyword">if</span> options.do_zscore &amp;&amp; all(cellfun(@isnumeric,xp2.data(:))) &amp;&amp; ~is_image
0343     mydata = xp2.data;
0344     <span class="keyword">for</span> i = 1:numel(mydata)
0345         mydata{i} = zscore(mydata{i});
0346     <span class="keyword">end</span>
0347     xp2.data = mydata;
0348 <span class="keyword">end</span>
0349 
0350 <span class="comment">% Shift the overlay by a certain amount</span>
0351 <span class="keyword">if</span> options.do_overlay_shift &amp;&amp; all(cellfun(@isnumeric,xp2.data(:))) &amp;&amp; ~is_image
0352     mydata = xp2.data;
0353     <span class="keyword">for</span> i = 1:numel(mydata)
0354         mydata{i} = <a href="#_sub19" class="code" title="subfunction mydata_out = do_shift_lastdim (mydata,shift)">do_shift_lastdim</a> (mydata{i},options.overlay_shift_val);
0355     <span class="keyword">end</span>
0356     xp2.data = mydata;
0357 <span class="keyword">end</span>
0358 
0359 <span class="comment">%% Squeeze out unused dimensions</span>
0360 <span class="comment">% Squeeze to eliminate superfluous dimensions</span>
0361 xp2 = xp2.squeeze;
0362 Nd = ndims(xp2);
0363 
0364 <span class="comment">% Rearrange dimensions of xp2 for stacking</span>
0365 <span class="keyword">if</span> ~isempty(options.dim_stacking)
0366     ax_names = xp2.exportAxisNames;
0367     <span class="keyword">if</span> length(options.dim_stacking) ~= length(ax_names) -1
0368         error(<span class="string">'Incorrect number of dimensions specified. dim_stacking must be some permutation of the following: %s'</span>, sprintf(<span class="string">'%s '</span>,ax_names{1:end-1}));
0369     <span class="keyword">end</span>
0370     xp2.permute(options.dim_stacking);
0371 <span class="keyword">end</span>
0372 
0373 
0374 <span class="comment">%% Crop data</span>
0375 <span class="comment">% This is inserted here because apparently the operation is slow and it's</span>
0376 <span class="comment">% faster to do this after we've already squeezed / selected.</span>
0377 <span class="keyword">if</span> ~isempty(crop_range) &amp;&amp;  all(cellfun(@isnumeric,xp2.data(:))) &amp;&amp; ~is_image
0378     t_temp = xp2.meta.datainfo(1).values;
0379     ind = (t_temp &gt; crop_range(1) &amp; t_temp &lt;= crop_range(2));
0380     <span class="keyword">for</span> i = 1:numel(xp2.data)
0381         <span class="keyword">if</span> ~isempty(xp2.data{i}); xp2.data{i} = xp2.data{i}(ind,:); <span class="keyword">end</span>
0382     <span class="keyword">end</span>
0383     xp2.meta.datainfo(1).values = t_temp(ind);
0384 <span class="keyword">end</span>
0385 
0386 
0387 
0388 <span class="comment">%% Set up legend entries and axis limits</span>
0389 <span class="comment">% Set up legend entries</span>
0390 subplot_options.legend1 = <a href="#_sub20" class="code" title="subfunction leg1 = setup_legends(xp2)">setup_legends</a>(xp2);
0391 
0392 
0393 <span class="comment">% Get axis lims</span>
0394 <span class="keyword">if</span> isempty(plot_options.xlims) &amp;&amp; lock_axes &amp;&amp; ~is_image
0395         xdat = xp2.meta.datainfo(1).values;
0396         plot_options.xlims = [min(xdat) max(xdat)];
0397 <span class="keyword">end</span>
0398 <span class="keyword">if</span> isempty(plot_options.ylims) &amp;&amp; lock_axes &amp;&amp; ~is_image
0399     <span class="keyword">switch</span> plot_type
0400         <span class="keyword">case</span> <span class="string">'waveform'</span>
0401             <span class="comment">% Merge all data into one single huge column</span>
0402             data_all = xp2.data(:);
0403             data_all = cellfunu(@(x) x(:), data_all);
0404             data_all = vertcat(data_all{:});
0405             <span class="comment">% Find the max and minima - these are the largest and smallest</span>
0406             <span class="comment">% values we could ever see.</span>
0407             data_lims = [min(data_all) max(data_all)];
0408             plot_options.ylims = data_lims;
0409     <span class="keyword">end</span>
0410 <span class="keyword">end</span>
0411 
0412 <span class="keyword">if</span> isempty(plot_options.zlims) &amp;&amp; lock_axes &amp;&amp; ~is_image
0413     <span class="keyword">switch</span> plot_type
0414         <span class="keyword">case</span> <span class="string">'imagesc'</span>
0415             data_all = xp2.data(:);
0416             data_all = cellfunu(@(x) x(:), data_all);
0417             data_all = vertcat(data_all{:});
0418             data_lims = [min(data_all) max(data_all)];
0419             plot_options.zlims = data_lims;
0420     <span class="keyword">end</span>
0421 <span class="keyword">end</span>
0422 
0423 <span class="comment">%% Prepare plotting handles for specific plot types</span>
0424 <span class="keyword">if</span> is_image
0425     <span class="comment">% Is an image</span>
0426     data_plothandle = @xp_plotimage;
0427     plot_options.scale = .5;           <span class="comment">% Scale of .5 enforces some anti-aliasing</span>
0428 <span class="keyword">else</span>
0429     <span class="keyword">switch</span> plot_type
0430         <span class="keyword">case</span> <span class="string">'waveform'</span>
0431             <span class="comment">% Is data</span>
0432             data_plothandle = @xp_matrix_advancedplot3D;
0433         <span class="keyword">case</span> <span class="string">'imagesc'</span>
0434             data_plothandle = @xp_matrix_imagesc;
0435             <span class="comment">% Disable legend when using imagesc</span>
0436             subplot_options.legend1 = [];
0437             <span class="comment">% Add time information</span>
0438             plot_options.xdat = xp2.meta.datainfo(1).values;
0439             <span class="comment">% Control colorbar</span>
0440             <span class="keyword">if</span> lock_axes
0441                 <span class="comment">% If axes are locked, only need to show 1 colorbar across</span>
0442                 <span class="comment">% all subplots</span>
0443                 subplot_options.do_colorbar = options.show_colorbar;         
0444                 plot_options.do_colorbar = false;
0445 <span class="comment">%                 subplot_options.do_colorbar = false;</span>
0446 <span class="comment">%                 plot_options.do_colorbar = true;</span>
0447             <span class="keyword">else</span>
0448                 subplot_options.do_colorbar = false;         
0449                 plot_options.do_colorbar = options.show_colorbar;
0450             <span class="keyword">end</span>
0451             
0452         <span class="keyword">case</span> {<span class="string">'power'</span>,<span class="string">'rastergram'</span>,<span class="string">'raster'</span>}
0453             <span class="comment">% Disable legend when using ds.plotData</span>
0454             subplot_options.legend1 = [];
0455             
0456             <span class="comment">% Setup call to xp_ds.plotData</span>
0457             plot_options.args = {plot_options.args{:}, <span class="string">'plot_type'</span>,plot_type};
0458             data_plothandle = @xp_ds.plotData;
0459             
0460             <span class="keyword">if</span> any(strcmp(plot_type,{<span class="string">'rastergram'</span>,<span class="string">'raster'</span>}))
0461                 <span class="comment">% Move populations axis to the end of xp2. This ensures</span>
0462                 ax_names = xp2.exportAxisNames;
0463                 ind_pop = false(1,length(ax_names));
0464                 ind_pop(xp2.findaxis(<span class="string">'populations'</span>)) = true;
0465                 ind_rest = ~ind_pop;
0466                 order = [find(ind_rest) find(ind_pop)];
0467                 xp2 = xp2.permute(order);
0468                 Ndims_pass_to_data = 2;                 <span class="comment">% Overwrite Ndims_pass_to_data to 2. This ensures</span>
0469                                                         <span class="comment">% that multiple populations can be stacked in a</span>
0470                                                         <span class="comment">% single subplot.</span>
0471             <span class="keyword">end</span>
0472             
0473         <span class="keyword">case</span> {<span class="string">'heatmapFR'</span>,<span class="string">'heatmap_sortedFR'</span>,<span class="string">'meanFR'</span>,<span class="string">'meanFRdens'</span>}
0474             <span class="comment">% Disable legend when using ds.plotFR2</span>
0475             subplot_options.legend1 = [];
0476             <span class="comment">% Remove FR suffix from heatmap and heatmap_sorted plot types</span>
0477             <span class="keyword">if</span> any(strcmp(plot_type,{<span class="string">'heatmapFR'</span>,<span class="string">'heatmap_sortedFR'</span>}))
0478                 plot_type = strrep(plot_type,<span class="string">'FR'</span>,<span class="string">''</span>);
0479             <span class="keyword">end</span>
0480             
0481             <span class="comment">% Setup call to xp_ds.plotFR2</span>
0482             plot_options.args = {plot_options.args{:}, <span class="string">'plot_type'</span>,plot_type};
0483             data_plothandle = @xp_ds.plotFR2;
0484     <span class="keyword">end</span>
0485 <span class="keyword">end</span>
0486 
0487 <span class="comment">%% Prepare plotting structure depending on number of embedded subplots</span>
0488 <span class="comment">% Split available axes into the number of dimensions supported by each</span>
0489 <span class="comment">% axis handle</span>
0490 <span class="keyword">switch</span> num_embedded_subplots
0491     <span class="keyword">case</span> 1
0492         <span class="comment">% Ordering of axis handles</span>
0493         <a name="_sub1" href="#_subfunctions" class="code">function_handles = {@xp_handles_newfig, @xp_subplot_grid,data_plothandle};   </a><span class="comment">% Specifies the handles of the plotting functions</span>
0494         dims_per_function_handle = [1,1,Ndims_pass_to_data];
0495         <a name="_sub2" href="#_subfunctions" class="code">function_args = {{figure_options},{subplot_options},{plot_options}};</a>
0496         
0497     <span class="keyword">case</span> 2
0498         <span class="comment">% Ordering of axis handles</span>
0499         <a name="_sub3" href="#_subfunctions" class="code">function_handles = {@xp_handles_newfig, @xp_subplot_grid,data_plothandle};   </a><span class="comment">% Specifies the handles of the plotting functions</span>
0500         dims_per_function_handle = [1,2,Ndims_pass_to_data];
0501         <a name="_sub4" href="#_subfunctions" class="code">function_args = {{figure_options},{subplot_options},{plot_options}};</a>
0502         
0503     <span class="keyword">case</span> 3
0504         <span class="comment">% Ordering of axis handles</span>
0505         <a name="_sub5" href="#_subfunctions" class="code">function_handles = {@xp_handles_newfig, @xp_subplot_grid, @xp_subplot_grid,data_plothandle};   </a><span class="comment">% Specifies the handles of the plotting functions</span>
0506         dims_per_function_handle = [1,2,1,Ndims_pass_to_data];
0507         subplot_options2 = subplot_options;
0508         subplot_options2.legend1 = [];
0509         subplot_options.display_mode = 1;
0510         <a name="_sub6" href="#_subfunctions" class="code">function_args = {{figure_options},{subplot_options2},{subplot_options},{plot_options}};</a>
0511     <span class="keyword">case</span> 4
0512         <span class="comment">% Ordering of axis handles</span>
0513         <a name="_sub7" href="#_subfunctions" class="code">function_handles = {@xp_handles_newfig, @xp_subplot_grid, @xp_subplot_grid,data_plothandle};   </a><span class="comment">% Specifies the handles of the plotting functions</span>
0514         dims_per_function_handle = [1,2,2,Ndims_pass_to_data];
0515         subplot_options2 = subplot_options;
0516         subplot_options2.legend1 = [];
0517         subplot_options.display_mode = 1;
0518         <a name="_sub8" href="#_subfunctions" class="code">function_args = {{figure_options},{subplot_options2},{subplot_options},{plot_options}};</a>
0519 <span class="keyword">end</span>
0520 
0521 
0522 <span class="comment">%% Auto trim dimensions as needed</span>
0523 <span class="comment">% Linearize dimensions of xp2 that are in excess of the total number we can</span>
0524 <span class="comment">% plot</span>
0525 maxNplotdims = sum(dims_per_function_handle)-1;
0526 xp2 = <a href="#_sub16" class="code" title="subfunction xp2 = reduce_dims(xp2,maxNplotdims)">reduce_dims</a>(xp2,maxNplotdims);
0527 
0528 <span class="comment">% Stack up available dimensions based on how much each axis handle can hold</span>
0529 ax_names = [xp2.exportAxisNames, <span class="string">'data'</span>];
0530 
0531 dimensions = <a href="#_sub15" class="code" title="subfunction dimensions = get_dimensions(ax_names,dims_per_function_handle)">get_dimensions</a>(ax_names,dims_per_function_handle);
0532 
0533 
0534 <span class="comment">% Remove any excess function handles that aren't needed</span>
0535 available_dims = ~cellfun(@isempty,dimensions);
0536 <a name="_sub9" href="#_subfunctions" class="code">function_handles = function_handles(available_dims);</a>
0537 dimensions = dimensions(available_dims);
0538 <a name="_sub10" href="#_subfunctions" class="code">function_args = function_args(available_dims);</a>
0539 
0540 
0541 <span class="comment">%% Run the plots!</span>
0542 <span class="comment">% Open new figure if necessary &amp; plot the data</span>
0543 <span class="keyword">if</span> ~isequal(@xp_handles_newfig, <a href="#_sub9" class="code" title="subfunction_handles = function_handles(available_dims);">function_handles</a>{1})
0544     <span class="comment">% Cheap hack to force it to create a new figure using our desired</span>
0545     <span class="comment">% parameters for instances when it wouldn't normally call</span>
0546     <span class="comment">% xp_handles_newfig.</span>
0547     xp3 = xPlt;
0548     fhandle = @() recursivePlot(xp2,<a href="#_sub9" class="code" title="subfunction_handles = function_handles(available_dims);">function_handles</a>,dimensions,<a href="#_sub10" class="code" title="subfunction_args = function_args(available_dims);">function_args</a>);
0549     xp3 = xp3.importData({fhandle});
0550     handles = xp_handles_newfig(xp3,figure_options);
0551 <span class="keyword">else</span>
0552     handles = xp2.recursivePlot(<a href="#_sub9" class="code" title="subfunction_handles = function_handles(available_dims);">function_handles</a>,dimensions,<a href="#_sub10" class="code" title="subfunction_args = function_args(available_dims);">function_args</a>);
0553 <span class="keyword">end</span>
0554 
0555 
0556 <span class="keyword">end</span>
0557 
0558 
0559 <a name="_sub11" href="#_subfunctions" class="code">function var_out = getdefaultstatevar(xp)</a>
0560     <span class="comment">% search through and try to find the variable represnting voltage. If can't find</span>
0561     <span class="comment">% it, just return the first variable listed.</span>
0562     
0563     <span class="comment">% See if variables axis even exists</span>
0564     <span class="keyword">if</span> isempty(xp.findaxis(<span class="string">'variables'</span>))
0565         <span class="comment">% If reach here, it means variables is not used in the code. Just</span>
0566         <span class="comment">% return some dummy values and move on.</span>
0567         var_out = <span class="string">':'</span>; 
0568         <span class="keyword">return</span>;
0569     <span class="keyword">end</span>
0570     
0571     vars_from_labels = <a href="../functions/supporting_ds.ds2xPlt/ds.xPlt.get_variables_from_meta.html" class="code" title="function varlabels = ds.xPlt.get_variables_from_meta(xp)">ds.xPlt.get_variables_from_meta</a>(xp);
0572     <span class="keyword">if</span> ~isempty(vars_from_labels)
0573         vars_from_labels = vars_from_labels(1);   <span class="comment">% Best guess at default state variable. Usually its the 1st entry in labels</span>
0574     <span class="keyword">end</span>
0575     
0576     <span class="comment">% Pull out variables</span>
0577     vars_orig = xp.axis(<span class="string">'variables'</span>).values;
0578     
0579     <span class="comment">% Make everything uppercase to ensure</span>
0580     <span class="comment">% case-insensitive.</span>
0581     vars = upper(vars_orig);
0582     possibilities = upper({vars_from_labels{:},<span class="string">'V'</span>,<span class="string">'X'</span>,<span class="string">'Vm'</span>,<span class="string">'Xm'</span>,<span class="string">'Y'</span>,<span class="string">'Ym'</span>});
0583     
0584     ind = [];
0585     i=0;
0586     <span class="keyword">while</span> isempty(ind) &amp;&amp; i &lt; length(possibilities)
0587         i=i+1;
0588         ind = find(strcmpi(vars,possibilities{i}));
0589     <span class="keyword">end</span>
0590     
0591     <span class="keyword">if</span> ~isempty(ind)
0592         var_out = vars_orig{ind};
0593     <span class="keyword">else</span>
0594         var_out = vars_orig{1};
0595     <span class="keyword">end</span>
0596 <span class="keyword">end</span>
0597 
0598 <a name="_sub12" href="#_subfunctions" class="code">function [chosen_varied, options_varied ]= get_chosen_varied(varied_names,options_varied)</a>
0599 
0600     <span class="comment">% Initialize output</span>
0601     chosen_varied = repmat({<span class="string">':'</span>},1,length(varied_names));
0602     
0603     <span class="comment">% Varied name-value pairs entered by user</span>
0604     varied_NVPs = fieldnames(options_varied);
0605     
0606     <span class="comment">% See if any of these match actual varied parameters</span>
0607     <span class="keyword">for</span> i =  1:length(varied_NVPs)
0608         ind = find(strcmp(varied_names,varied_NVPs{i}));
0609         <span class="keyword">if</span> length(ind) == 1
0610             chosen_varied{ind} = options_varied.(varied_NVPs{i});
0611             
0612             <span class="comment">% Optional (remove from options_varied)</span>
0613             options_varied = rmfield(options_varied,varied_NVPs{i});
0614         <span class="keyword">elseif</span> length(ind) &gt; 1
0615             error(<span class="string">'Multiple varied arguments found'</span>);
0616         <span class="keyword">else</span>
0617             <span class="comment">% Not a varied variable name</span>
0618         <span class="keyword">end</span>
0619         
0620         
0621     <span class="keyword">end</span>
0622     
0623 <span class="keyword">end</span>
0624 
0625 <a name="_sub13" href="#_subfunctions" class="code">function str_out = variedN_to_axisnames(str_in,ax_names_varied)</a>
0626 
0627         <span class="keyword">if</span> strcmp(str_in(1:min(6,end)),<span class="string">'varied'</span>)        <span class="comment">% User has entered variedX</span>
0628             <span class="comment">% fn is original fieldname (e.g. variedX)</span>
0629             <span class="comment">% fn2 is new field name of varied parameter (e.g. E_Iapp)</span>
0630             str_out = ax_names_varied{str2num(str_in(7:end))};
0631         <span class="keyword">else</span>
0632             str_out = str_in;
0633         <span class="keyword">end</span>
0634     
0635 <span class="keyword">end</span>
0636 
0637 <a name="_sub14" href="#_subfunctions" class="code">function ax_ind_varied = findaxis_varied(xp)</a>
0638     <span class="comment">% Uses metadata to identify a list of varied variables. Then validates</span>
0639     <span class="comment">% that they match the available axis names and returns their index.</span>
0640     varied = xp.meta.dynasim.varied;
0641     ax_names = xp.exportAxisNames;
0642     ax_ind_varied = false(1,length(ax_names));
0643     <span class="keyword">for</span> i = 1:length(varied)
0644         ind = strcmp(varied{i},ax_names);
0645         <span class="keyword">if</span> sum(ind) ~= 1; error(<span class="string">'Varied axis not found OR something wrong with varied label'</span>); <span class="keyword">end</span>
0646         ax_ind_varied = ax_ind_varied | ind;
0647     <span class="keyword">end</span>
0648     
0649     ax_ind_varied = find(ax_ind_varied);
0650 <span class="keyword">end</span>
0651 
0652 <a name="_sub15" href="#_subfunctions" class="code">function dimensions = get_dimensions(ax_names,dims_per_function_handle)</a>
0653     <span class="comment">% Split available axes into the number of dimensions supported by each</span>
0654     <span class="comment">% axis handle</span>
0655 
0656     i = length(dims_per_function_handle);
0657     <span class="keyword">while</span> i &gt; 0 &amp;&amp; ~isempty(ax_names)
0658         
0659         Ndims_curr = dims_per_function_handle(i);
0660         dimensions{i} = ax_names(max(1,end-Ndims_curr+1):end);
0661         ax_names = ax_names(1:end-Ndims_curr);
0662         i=i-1;
0663     <span class="keyword">end</span>
0664     
0665 <span class="keyword">end</span>
0666 
0667 
0668 
0669 <a name="_sub16" href="#_subfunctions" class="code">function xp2 = reduce_dims(xp2,maxNplotdims)</a>
0670     Nd = ndims(xp2);
0671     <span class="keyword">if</span> Nd &gt; maxNplotdims 
0672         xp2 = xp2.mergeDims( [maxNplotdims:Nd] );
0673         xp2 = xp2.squeeze;
0674         Nd = ndims(xp2);
0675 
0676         <span class="keyword">if</span> Nd ~= maxNplotdims; error(<span class="string">'something wrong'</span>); <span class="keyword">end</span>
0677     <span class="keyword">end</span>
0678 <span class="keyword">end</span>
0679 
0680 <a name="_sub17" href="#_subfunctions" class="code">function varied_names = only_varieds(xp)</a>
0681     <span class="comment">% Get list of varied axis names</span>
0682     varied_names = xp.meta.dynasim.varied;
0683     
0684     <span class="comment">% Make sure that they are acutally in xp.axis.names.</span>
0685     <a href="#_sub14" class="code" title="subfunction ax_ind_varied = findaxis_varied(xp)">findaxis_varied</a>(xp); <span class="comment">% This function will return an error if they are missing!</span>
0686     
0687 <span class="keyword">end</span>
0688 
0689 
0690 <a name="_sub18" href="#_subfunctions" class="code">function varied_names = only_varieds_old_deleteme(all_names)</a>
0691     warning(<span class="string">'update this command or possibly merge with findaxis_varied'</span>);
0692     inds = true(1,length(all_names));
0693     inds(strcmp(all_names,<span class="string">'populations'</span>)) = false; 
0694     inds(strcmp(all_names,<span class="string">'variables'</span>)) = false;
0695     varied_names = all_names(inds);
0696 <span class="keyword">end</span>
0697 
0698 <a name="_sub19" href="#_subfunctions" class="code">function mydata_out = do_shift_lastdim (mydata,shift)</a>
0699     sz = size(mydata);
0700     nd = ndims(mydata);
0701     
0702     <span class="keyword">if</span> isempty(shift)
0703         <span class="comment">% Do adaptive shift</span>
0704         upscale_factor = 2;
0705         temp = reshape(mydata,prod(sz(1:nd-1)),sz(nd));
0706         stdevs = nanstd(temp)*upscale_factor;               <span class="comment">% STD ignoring NaNs</span>
0707         sh = [0, stdevs(1:end-1) + stdevs(2:end)]';
0708         sh = sh * -1;        <span class="comment">% Forces shifts to be downward (same as subplots)</span>
0709     <span class="keyword">else</span>
0710         sh = shift*[0:sz(end)-1]';      <span class="comment">% Fixed shift amount</span>
0711         sh = sh * -1;        <span class="comment">% Forces shifts to be downward (same as subplots)</span>
0712     <span class="keyword">end</span>
0713     
0714     
0715     sh = permute(sh, [2:nd,1]);
0716     <span class="keyword">if</span> length(sz(1:nd-1)) == 1
0717         sh2 = repmat(sh, sz(1:nd-1),1);     <span class="comment">% Special case for scalar input to repmat. When repmat receives a scalar, it repeats BOTH rows and columns instead of just rows</span>
0718     <span class="keyword">else</span>
0719         sh2 = repmat(sh, sz(1:nd-1));
0720     <span class="keyword">end</span>
0721     
0722     mydata_out = mydata + sh2;
0723     
0724 <span class="keyword">end</span>
0725 
0726 <a name="_sub20" href="#_subfunctions" class="code">function leg1 = setup_legends(xp2)</a>
0727     
0728     <span class="comment">% Pull out all metadata names and values</span>
0729     <span class="keyword">for</span> i = 1:length(xp2.meta.datainfo)
0730         mn{i} = xp2.meta.datainfo(i).name;
0731         mv{i} = xp2.meta.datainfo(i).values;
0732     <span class="keyword">end</span>
0733 
0734     <span class="comment">% Convert any numeric entries to cell strings as needed</span>
0735     <span class="keyword">for</span> i = 2:length(xp2.meta.datainfo)
0736         <span class="keyword">if</span> isnumeric(mv{i})
0737             <span class="comment">% If axis is numeric, as in the case with varied parameters, convert to</span>
0738             <span class="comment">% a cell array of strings</span>
0739             mv{i} = cellfun(@num2str,num2cell(mv{i}),<span class="string">'UniformOutput'</span>,0);
0740 
0741             <span class="comment">% Also pre-pend the name of the variable being varied</span>
0742             <span class="keyword">for</span> j = 1:length(mv{i})
0743                 mv{i}{j} = [strrep(mn{i},<span class="string">'_'</span>,<span class="string">' '</span>) <span class="string">' '</span> mv{i}{j}];
0744             <span class="keyword">end</span>
0745         <span class="keyword">end</span>
0746     <span class="keyword">end</span>
0747     
0748     <span class="keyword">if</span> length(mv) == 2
0749         leg1 = mv{2};
0750     <span class="keyword">elseif</span> length(mv) == 3
0751         <span class="comment">%Cartesean product of mv{2} and mv{3}</span>
0752         k = 0;
0753         <span class="keyword">for</span> j = 1:length(mv{3})
0754             <span class="keyword">for</span> i = 1:length(mv{2})         <span class="comment">% We plot the 2nd dimension 1st; they are grouped together</span>
0755                 k=k+1;
0756                 leg1{k} = [mv{2}{i} <span class="string">' '</span> mv{3}{j}];
0757             <span class="keyword">end</span>
0758         <span class="keyword">end</span>
0759     <span class="keyword">else</span>
0760         error(<span class="string">'should not reach'</span>);
0761     <span class="keyword">end</span>
0762 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Fri 07-Apr-2017 20:01:20 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>