<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of getBurstGating</title>
  <meta name="keywords" content="getBurstGating">
  <meta name="description" content="T=0:.01:1000; f=10; w=10; nspk=10; dc=0; Npop=2; minIBI=0; meanIBI=0; [sext,ts,Ptot,Peg]=getBurstGating(T,f,w,nspk,dc,Npop,minIBI,meanIBI,2,1,ones(1,Npop),0,0,inf,0,0,1);">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- menu.html functions -->
<h1>getBurstGating
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>T=0:.01:1000; f=10; w=10; nspk=10; dc=0; Npop=2; minIBI=0; meanIBI=0; [sext,ts,Ptot,Peg]=getBurstGating(T,f,w,nspk,dc,Npop,minIBI,meanIBI,2,1,ones(1,Npop),0,0,inf,0,0,1);</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function [sext,tstart,Ptot,sources_eg]=getBurstGating(T,freq,width,num_spikes,dc,num_targets,minIBI,meanIBI,tau,kick,kernel,shared_sources_flag,onset,offset,ramp_dc_flag,ramp_ac_flag,num_sources) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> T=0:.01:1000; f=10; w=10; nspk=10; dc=0; Npop=2; minIBI=0; meanIBI=0; [sext,ts,Ptot,Peg]=getBurstGating(T,f,w,nspk,dc,Npop,minIBI,meanIBI,2,1,ones(1,Npop),0,0,inf,0,0,1);
 ds.plotData(sext)</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="nonhomPoissonGeneratorSpikeTimes.html" class="code" title="function S = nonhomPoissonGeneratorSpikeTimes(S_ini,rate,tau,kick,N,interval,dt)">nonhomPoissonGeneratorSpikeTimes</a>	</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
</ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="#_sub1" class="code">function S = nonhomPoissonGeneratorSpikeTimes(S_ini,Ptot,tau,kick,num_targets,nt,dt)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [sext,tstart,Ptot,sources_eg]=getBurstGating(T,freq,width,num_spikes,dc,num_targets,minIBI,meanIBI,tau,kick,kernel,shared_sources_flag,onset,offset,ramp_dc_flag,ramp_ac_flag,num_sources)</a>
0002 <span class="comment">% T=0:.01:1000; f=10; w=10; nspk=10; dc=0; Npop=2; minIBI=0; meanIBI=0; [sext,ts,Ptot,Peg]=getBurstGating(T,f,w,nspk,dc,Npop,minIBI,meanIBI,2,1,ones(1,Npop),0,0,inf,0,0,1);</span>
0003 <span class="comment">% ds.plotData(sext)</span>
0004 
0005 <span class="comment">% Poisson-based spike bursts with variable spike synchrony</span>
0006 <span class="comment">% Bursts can occur periodically or with exponentially-distributed</span>
0007 <span class="comment">% interburst intervals. The number of spikes per burst can be controlled or</span>
0008 <span class="comment">% be specified by a fixed amplitude ac of rate modulation.</span>
0009 
0010 <span class="comment">% arguments:</span>
0011 <span class="comment">%   num_spikes: # of spikes per burst</span>
0012 <span class="comment">%   Nsources:</span>
0013 <span class="comment">%   Ntargets:</span>
0014 <span class="comment">%   dc: constant homogeneous Poisson dc offset [Hz]</span>
0015 <span class="comment">%   width: burst width (width) [sec]</span>
0016 <span class="comment">%   freq</span>
0017 
0018 <span class="comment">% f=0: use exponential IBIs (meanIBI,minIBI=width)</span>
0019 <span class="comment">% f&gt;0: set Tibi=(1/f)-width</span>
0020 <span class="comment">% width: burst width [ms]</span>
0021 <span class="comment">% num_spikes: # of spikes per burst (DC+AC components)</span>
0022 <span class="comment">% dc: constant offset [Hz]</span>
0023 
0024 <span class="comment">% tip: input is sinusoidal if (1/freq)=width</span>
0025 <span class="comment">% tip: set minIBI to max width used across simulations to get similar #</span>
0026 <span class="comment">%      bursts for different levels of spike synchrony</span>
0027 
0028 <span class="comment">% constraints:</span>
0029 <span class="comment">% 1. next burst cannot begin until the previous one completes</span>
0030 <span class="comment">%   f&gt;0: (1/freq) &gt;= width</span>
0031 <span class="comment">%   f=0: min(Tibi) &gt;= width, where Tibi~exp(IBImean)</span>
0032 <span class="comment">% 2. exactly num_spikes should occur in the ac component only (i.e., in addition to spontaneous background activity)</span>
0033 
0034 <span class="keyword">if</span> nargin&lt;1, T=0:.01:1000; <span class="keyword">end</span>                <span class="comment">% [ms]</span>
0035 <span class="keyword">if</span> nargin&lt;2, freq=10; <span class="keyword">end</span>                     <span class="comment">% [Hz]</span>
0036 <span class="keyword">if</span> nargin&lt;3, <span class="keyword">if</span> freq==0, width=.1*T(end); <span class="keyword">else</span> width=.1*(1/freq)*1000; <span class="keyword">end</span>; <span class="keyword">end</span> <span class="comment">% [ms]</span>
0037 <span class="keyword">if</span> nargin&lt;4, num_spikes=100; <span class="keyword">end</span>
0038 <span class="keyword">if</span> nargin&lt;5, dc=0; <span class="keyword">end</span>                        <span class="comment">% [Hz]?</span>
0039 <span class="keyword">if</span> nargin&lt;6, num_targets=1; <span class="keyword">end</span>
0040 <span class="keyword">if</span> nargin&lt;7, minIBI=2*width; <span class="keyword">end</span>              <span class="comment">% [ms]</span>
0041 <span class="keyword">if</span> nargin&lt;8, meanIBI=10*width; <span class="keyword">end</span>            <span class="comment">% [ms]</span>
0042 <span class="keyword">if</span> nargin&lt;9, tau=2; <span class="keyword">end</span>                       <span class="comment">% [ms]</span>
0043 <span class="keyword">if</span> nargin&lt;10, kick=1; <span class="keyword">end</span>                     <span class="comment">% [uA/cm2]</span>
0044 <span class="keyword">if</span> nargin&lt;11, kernel=ones(1,num_targets); <span class="keyword">end</span>
0045 <span class="keyword">if</span> nargin&lt;12, shared_sources_flag=0; <span class="keyword">end</span>
0046 <span class="keyword">if</span> nargin&lt;13, onset=0; <span class="keyword">end</span>                    <span class="comment">% [ms]</span>
0047 <span class="keyword">if</span> nargin&lt;14, offset=inf; <span class="keyword">end</span>                 <span class="comment">% [ms]</span>
0048 <span class="keyword">if</span> nargin&lt;15, ramp_dc_flag=0; <span class="keyword">end</span>
0049 <span class="keyword">if</span> nargin&lt;16, ramp_ac_flag=0; <span class="keyword">end</span>
0050 <span class="keyword">if</span> nargin&lt;17, num_sources=1; <span class="keyword">end</span>
0051 
0052 <span class="comment">% num_sources=10;   % # of simulated inputs</span>
0053 <span class="comment">% num_targets=2;    % # of model cells in target population</span>
0054 <span class="comment">% num_spikes=200;   % # spikes per burst (ac-component will be scaled to achieve num_spikes per burst)</span>
0055 <span class="comment">% width=10;         % ms, width of burst (i.e., input spike synchrony) (default: 10% of sim or cycle)</span>
0056 <span class="comment">% freq=10;          % Hz, modulation frequency</span>
0057 <span class="comment">% dc=0;             % Hz, non-modulated rate component (dc offset) of the burst</span>
0058 <span class="comment">% minIBI=10;        % ms, min interburst interval (set &gt;= max width used across simulations) (default: width)</span>
0059 <span class="comment">% meanIBI=100;      % ms, mean interburst interval (default: 10*width)</span>
0060 <span class="comment">% tau=2;            % ms, synaptic time constant</span>
0061 <span class="comment">% kick=1;           % uA/cm2, conductance kick per spike</span>
0062 <span class="comment">% T=0:.01:1000;     % ms, time vector</span>
0063 <span class="comment">% kernel=ones(num_targets,1); % input kernel</span>
0064 <span class="comment">% shared_sources_flag=0; % 0 or 1, whether targets share the same sources and thus receive</span>
0065 <span class="comment">% onset=0;</span>
0066 <span class="comment">% offset=inf;</span>
0067 <span class="comment">% ramp_dc_flag=0;</span>
0068 <span class="comment">% ramp_ac_flag=0;</span>
0069 
0070 <span class="comment">% convert units to Hz and sec</span>
0071 onset=onset/1000;
0072 offset=offset/1000;
0073 width=width*2/1000;   <span class="comment">% sec, double to provide refractory burst half-cycle</span>
0074 minIBI=minIBI/1000;   <span class="comment">% sec</span>
0075 meanIBI=meanIBI/1000; <span class="comment">% sec</span>
0076 dt=(T(2)-T(1))/1000;  <span class="comment">% sec, fixed integration time step</span>
0077 tdur=T(end)/1000;     <span class="comment">% sec, duration of simulation</span>
0078 t=0:dt:tdur;          <span class="comment">% sec, time vector</span>
0079 nt=length(t);
0080 
0081 <span class="comment">% 1.0 Construct time-varying lambda</span>
0082 <span class="comment">% calculate amplitude of ac component necessary to achieve desired num_spikes per burst</span>
0083 ac=(num_spikes-dc*(width/2))*(pi/(width*dt))/100000;
0084 <span class="comment">% rate-modulation for one burst</span>
0085 yburst=sin(2*pi*(0:dt:width)/width); <span class="comment">% -1 to 1</span>
0086 <span class="comment">% burst start times</span>
0087 <span class="keyword">if</span> freq==0 <span class="comment">% exponentially-distributed interburst intervals (IBIs) (i.e., poisson bursting)</span>
0088   Tibi_=exprnd(meanIBI,[nt 1]);
0089   Tibi=Tibi_(Tibi_(:,1)&gt;=minIBI,1);
0090   tstart=[0 cumsum(Tibi')];
0091 <span class="keyword">else</span> <span class="comment">% fixed-period interburst intervals (i.e., rhythmic bursting)</span>
0092   Tibi0=(1/freq)-width; <span class="comment">% sec, time b/w end of one burst and beginning of the next</span>
0093   Tosc=width+Tibi0; <span class="comment">% time b/w start of one burst and start of the next (i.e., period of effective modulation frequency)</span>
0094   tstart=0:Tosc:tdur; <span class="comment">% start times for each burst</span>
0095 <span class="keyword">end</span>
0096 tstart=tstart(tstart&lt;tdur);
0097 <span class="comment">% insert burst every interburst interval</span>
0098 yac=zeros(size(t));
0099 ydc=zeros(size(t));
0100 <span class="keyword">for</span> i=1:length(tstart)
0101   ton=tstart(i);
0102   ind=nearest(t,ton):nearest(t,ton+width);
0103   yac(ind)=yburst(1:length(ind));
0104   ydc(ind)=1;
0105 <span class="keyword">end</span>
0106 <span class="comment">% account for ramping within-burst-DC component</span>
0107 <span class="keyword">if</span> ramp_dc_flag&gt;0
0108   DC=zeros(size(t));
0109   tind=find(t&gt;=onset&amp;t&lt;=offset);
0110   DC(tind)=linspace(0,dc,length(tind));
0111 <span class="keyword">else</span>
0112   DC=dc*ones(size(ydc));
0113 <span class="keyword">end</span>
0114 <span class="comment">% account for ramping within-burst-AC component</span>
0115 <span class="keyword">if</span> ramp_ac_flag&gt;0
0116   AC=zeros(size(t));
0117   tind=find(t&gt;=onset&amp;t&lt;=offset);
0118   AC(tind)=linspace(0,ac,length(tind));
0119 <span class="keyword">else</span>
0120   AC=ac*ones(size(yac));
0121 <span class="keyword">end</span>
0122 lambda_=max(AC.*yac+DC.*ydc,0);  <span class="comment">% kHz, nonhomogeneous poisson rate, 0 to (dc+ac)</span>
0123 <span class="comment">% limit spiking to [onset,offset]</span>
0124 lambda_(t&lt;onset|t&gt;offset)=0;
0125 <span class="comment">% apply input kernel to weight input for select targets</span>
0126 lambda=kernel'*lambda_;
0127 <span class="comment">% 2.0 Construct source Poisson process where every target has exactly</span>
0128 <span class="comment">% num_spikes AC-modulated input spikes across all sources for each burst</span>
0129 Ptot=zeros(nt,num_targets);
0130 <span class="keyword">for</span> k=1:num_targets <span class="comment">% loop over targets</span>
0131   <span class="keyword">if</span> k&gt;1 &amp;&amp; shared_sources_flag
0132     Ptot(:,k)=Ptot(:,1);
0133     <span class="keyword">continue</span>;
0134   <span class="keyword">end</span>
0135   P=poissrnd(2*lambda(k,:)*dt);  <span class="comment">% poisson process (2x to make sure we get at least num_spikes)</span>
0136   <span class="comment">% constrain s.t. exactly num_spikes occur per burst</span>
0137   <span class="keyword">for</span> i=1:length(tstart) <span class="comment">% loop over bursts</span>
0138     ton=tstart(i); <span class="comment">% start time for this burst</span>
0139     ind=nearest(t,ton):nearest(t,ton+width); <span class="comment">% indices for this burst</span>
0140     Pburst=P(ind);
0141     nspks=sum(Pburst(:));
0142     <span class="comment">% remove excess spikes uniformly, one at a time</span>
0143     <span class="keyword">for</span> j=1:(nspks-num_spikes)
0144       inds=find(Pburst&gt;0);
0145       sel=inds(randperm(length(inds),1)); <span class="comment">% select random spike to remove</span>
0146       <span class="comment">%sel=inds(randsample(length(inds),1)); % select random spike to remove</span>
0147       Pburst(sel)=Pburst(sel)-1; <span class="comment">% remove the spike from this burst</span>
0148     <span class="keyword">end</span>
0149     P(ind)=Pburst;
0150   <span class="keyword">end</span>
0151   Ptot(:,k)=P;
0152 <span class="keyword">end</span>
0153 <span class="comment">% 3.0 calculate gating (summed across sources for each target)</span>
0154 S_ini = zeros(1,num_targets);
0155 sext=<a href="nonhomPoissonGeneratorSpikeTimes.html" class="code" title="function S = nonhomPoissonGeneratorSpikeTimes(S_ini,rate,tau,kick,N,interval,dt)">nonhomPoissonGeneratorSpikeTimes</a>(S_ini',Ptot',tau,kick,num_targets,nt,dt*1000)';
0156 
0157 <span class="comment">% create example source population poisson process</span>
0158 <span class="comment">% distribute across a source population (num_sources)</span>
0159 lambda=repmat(lambda(1,:)/num_sources,[num_sources 1]);
0160 <span class="comment">% poisson process for all sources (use to calculate input spike coherence)</span>
0161 sources_eg=poissrnd(lambda*dt)'; <span class="comment">% [sources x time]</span>
0162 
0163 <span class="comment">% return target gating, source poisson process, and burst start times</span>
0164 <span class="comment">% sext                  sources_eg                  tstart</span>
0165 
0166 <span class="keyword">end</span>
0167 
0168 <a name="_sub1" href="#_subfunctions" class="code">function S = nonhomPoissonGeneratorSpikeTimes(S_ini,Ptot,tau,kick,num_targets,nt,dt)</a>
0169 <span class="comment">% original function created by Salva Ardid</span>
0170 
0171   S = zeros(num_targets,nt);
0172   <span class="keyword">for</span> i=1:num_targets <span class="comment">% loop over targets</span>
0173     <span class="comment">% Determine number of events in each time bin</span>
0174     p = Ptot(i,:);<span class="comment">%poissrnd(max(rate(i,:),0)*dt);</span>
0175     <span class="comment">% Get the proper length for the events</span>
0176     l = sum(p); <span class="comment">% # of spikes to target i</span>
0177     timeevents = zeros(1,l+1);
0178     <span class="comment">% For each dt compute the event times</span>
0179     ix = find(p); <span class="comment">% p diff than 0</span>
0180     cum = cumsum([1 p(ix)]);
0181     adds = diff([0 ix-1]);
0182     timeevents(cum(1:end-1)) = adds;
0183     timeevents(cum(end):end) = inf; <span class="comment">% no more spikes after that</span>
0184     timeevents = cumsum(timeevents); <span class="comment">% in dt units</span>
0185     timeevents = dt*sort(timeevents+rand(size(timeevents)));<span class="comment">% in each dt unit, the spike can happen anytime, with uniform distribution</span>
0186 
0187     S_tmp = S_ini(i);
0188     spikeTimePointer = 1;
0189     nextSpikeTime = timeevents(spikeTimePointer);
0190 
0191     time = 0;
0192     <span class="keyword">for</span> t = 1:nt
0193       time = time + dt;
0194       decayTime = dt;
0195       indSpikeNow = (nextSpikeTime&lt;=time);
0196       <span class="keyword">while</span> indSpikeNow
0197         decayTime = dt + (nextSpikeTime - time);
0198         S_tmp = S_tmp.*exp(-decayTime/tau);
0199         S_tmp = S_tmp + kick;
0200         decayTime = time - nextSpikeTime;
0201 
0202         spikeTimePointer = spikeTimePointer+1;
0203         nextSpikeTime = timeevents(spikeTimePointer);
0204         indSpikeNow = (nextSpikeTime&lt;=time);
0205       <span class="keyword">end</span>
0206       S_tmp = S_tmp.*exp(-decayTime/tau);
0207       S(i,t) = S_tmp;
0208     <span class="keyword">end</span>
0209   <span class="keyword">end</span>
0210 <span class="keyword">end</span>
0211</pre></div>
<hr><address>Generated on Fri 07-Apr-2017 20:01:20 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>