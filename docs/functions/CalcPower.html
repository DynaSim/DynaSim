<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of ds.calcPower</title>
  <meta name="keywords" content="ds.calcPower">
  <meta name="description" content="CALCPOWER - Compute spectral analysis of DynaSim data">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- menu.html functions -->
<h1>ds.calcPower
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>CALCPOWER - Compute spectral analysis of DynaSim data</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function data = ds.calcPower(data,varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment">CALCPOWER - Compute spectral analysis of DynaSim data

 Usage:
   data = ds.calcPower(data,'option',value)

 Inputs:
   - data: DynaSim data structure (see ds.checkData)
   - options:
     'variable'              : name of field containing data on which to
                               calculate firing rates (default: *_spikes or
                               first variable in data.labels)
     'time_limits'           : [beg,end] (units of data.time)
     'smooth_factor'         : number of samples for smoothing the spectrum (default: 5)
                               - tip: set to 1 to avoid smoothing
   - options for peak detection:
     'min_peak_frequency'    : Hz, min frequency for peak detection (default: 2)
     'max_peak_frequency'    : Hz, max frequency for peak detection (default: 150)
     'peak_threshold_prctile': percentile for setting power threshold for peak
                               detection (default: 95)
     'peak_area_width'       : Hz, size of frequency bin (centered on peak)
                               over which to calculate area under spectrum (default: 5)
     'exclude_data_flag'     : whether to remove simulated data from result
                               structure (default: 0)

 Outputs:
   - data structure organization:
     data.VARIABLE_Power_SUA.frequency: TODO
     data.VARIABLE_Power_SUA.PeakArea: area under spectrum around peak (one value per cell)
     data.VARIABLE_Power_SUA.PeakFreq: frequency of spectral power (one value per cell)
     data.VARIABLE_Power_SUA.Pxx: spectral power
   - if populations present, data also includes:
     data.VARIABLE_Power_MUA.frequency: TODO
     data.VARIABLE_Power_MUA.PeakArea: TODO
     data.VARIABLE_Power_MUA.PeakFreq: TODO
     data.VARIABLE_Power_MUA.Pxx: spectrum of the mean waveform
       - population mean spectrum of the individual waveforms can be
           calculated using &quot;mean(data.VARIABLE_Power_MUA.Pxx,2)&quot;.
   - Note:
     - &quot;VARIABLE&quot; can be specified as the name of a variable listed in
         data.labels, a cell array of string listing variable names, or as a
         regular expression pattern for identifying variables to process. See
         ds.selectVariables for more info on supported specifications.

 Examples:
   s=[];
   s.populations(1).name='E';
   s.populations(1).equations='dv[2]/dt=@current+10; {iNa,iK}; v(0)=-65';
   s.populations(2).name='I';
   s.populations(2).equations='dv/dt=@current+10; {iNa,iK}; v(0)=-65';
   data=ds.simulateModel(s,'tspan',[0 1000]);
   data=ds.calcPower(data,'variable','v');
   % Plot the spectrum of the E-cell average population voltage
   figure; plot(data.E_v_Power_MUA.frequency,data.E_v_Power_MUA.Pxx);
   xlabel('frequency (Hz)'); ylabel('power'); xlim([0 200]);

 See also: PlotPower, <a href="AnalyzeStudy.html" class="code" title="function [results,studyinfo]=AnalyzeStudy(data,func,varargin)">AnalyzeStudy</a>, <a href="ds.simulateModel.html" class="code" title="function [data,studyinfo]=ds.simulateModel(model,varargin)">ds.simulateModel</a>, <a href="ds.checkData.html" class="code" title="function data=ds.checkData(data)">ds.checkData</a>, <a href="ds.selectVariables.html" class="code" title="function [variables,pop_names]=ds.selectVariables(labels,var_strings)">ds.selectVariables</a>
% 1.0 Check inputs</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="AnalyzeStudy.html" class="code" title="function [results,studyinfo]=AnalyzeStudy(data,func,varargin)">AnalyzeStudy</a>	ANALYZESTUDY - Apply an analysis function to DynaSim data, optionally saving data</li><li><a href="ds.calcPower.html" class="code" title="function data = ds.calcPower(data,varargin)">ds.calcPower</a>	CALCPOWER - Compute spectral analysis of DynaSim data</li><li><a href="ds.checkData.html" class="code" title="function data=ds.checkData(data)">ds.checkData</a>	CHECKDATA - Standardize data structure and auto-populate missing fields</li><li><a href="ds.checkOptions.html" class="code" title="function [parms, params_unspecified ] = ds.checkOptions(options, options_schema, strict)">ds.checkOptions</a>	CHECKOPTIONS - organize key/value pairs in structure with default or user-supplied values according to a schema</li><li><a href="ds.selectVariables.html" class="code" title="function [variables,pop_names]=ds.selectVariables(labels,var_strings)">ds.selectVariables</a>	SELECTVARIABLES - determine what variables to plot</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="ds.calcPower.html" class="code" title="function data = ds.calcPower(data,varargin)">ds.calcPower</a>	CALCPOWER - Compute spectral analysis of DynaSim data</li><li><a href="ds.calcSpikeSync.html" class="code" title="function stats = ds.calcSpikeSync(data,varargin)">ds.calcSpikeSync</a>	CALCSPIKESYNC - Compute spike synchronization between spiketrains</li><li><a href="ds.plotData.html" class="code" title="function handles = ds.plotData(data,varargin)">ds.plotData</a>	PLOTDATA - plot data in various ways depending on what data was provided and what options are defined.</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function data = ds.calcPower(data,varargin)</a>
0002 <span class="comment">%CALCPOWER - Compute spectral analysis of DynaSim data</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% Usage:</span>
0005 <span class="comment">%   data = ds.calcPower(data,'option',value)</span>
0006 <span class="comment">%</span>
0007 <span class="comment">% Inputs:</span>
0008 <span class="comment">%   - data: DynaSim data structure (see ds.checkData)</span>
0009 <span class="comment">%   - options:</span>
0010 <span class="comment">%     'variable'              : name of field containing data on which to</span>
0011 <span class="comment">%                               calculate firing rates (default: *_spikes or</span>
0012 <span class="comment">%                               first variable in data.labels)</span>
0013 <span class="comment">%     'time_limits'           : [beg,end] (units of data.time)</span>
0014 <span class="comment">%     'smooth_factor'         : number of samples for smoothing the spectrum (default: 5)</span>
0015 <span class="comment">%                               - tip: set to 1 to avoid smoothing</span>
0016 <span class="comment">%   - options for peak detection:</span>
0017 <span class="comment">%     'min_peak_frequency'    : Hz, min frequency for peak detection (default: 2)</span>
0018 <span class="comment">%     'max_peak_frequency'    : Hz, max frequency for peak detection (default: 150)</span>
0019 <span class="comment">%     'peak_threshold_prctile': percentile for setting power threshold for peak</span>
0020 <span class="comment">%                               detection (default: 95)</span>
0021 <span class="comment">%     'peak_area_width'       : Hz, size of frequency bin (centered on peak)</span>
0022 <span class="comment">%                               over which to calculate area under spectrum (default: 5)</span>
0023 <span class="comment">%     'exclude_data_flag'     : whether to remove simulated data from result</span>
0024 <span class="comment">%                               structure (default: 0)</span>
0025 <span class="comment">%</span>
0026 <span class="comment">% Outputs:</span>
0027 <span class="comment">%   - data structure organization:</span>
0028 <span class="comment">%     data.VARIABLE_Power_SUA.frequency: TODO</span>
0029 <span class="comment">%     data.VARIABLE_Power_SUA.PeakArea: area under spectrum around peak (one value per cell)</span>
0030 <span class="comment">%     data.VARIABLE_Power_SUA.PeakFreq: frequency of spectral power (one value per cell)</span>
0031 <span class="comment">%     data.VARIABLE_Power_SUA.Pxx: spectral power</span>
0032 <span class="comment">%   - if populations present, data also includes:</span>
0033 <span class="comment">%     data.VARIABLE_Power_MUA.frequency: TODO</span>
0034 <span class="comment">%     data.VARIABLE_Power_MUA.PeakArea: TODO</span>
0035 <span class="comment">%     data.VARIABLE_Power_MUA.PeakFreq: TODO</span>
0036 <span class="comment">%     data.VARIABLE_Power_MUA.Pxx: spectrum of the mean waveform</span>
0037 <span class="comment">%       - population mean spectrum of the individual waveforms can be</span>
0038 <span class="comment">%           calculated using &quot;mean(data.VARIABLE_Power_MUA.Pxx,2)&quot;.</span>
0039 <span class="comment">%   - Note:</span>
0040 <span class="comment">%     - &quot;VARIABLE&quot; can be specified as the name of a variable listed in</span>
0041 <span class="comment">%         data.labels, a cell array of string listing variable names, or as a</span>
0042 <span class="comment">%         regular expression pattern for identifying variables to process. See</span>
0043 <span class="comment">%         ds.selectVariables for more info on supported specifications.</span>
0044 <span class="comment">%</span>
0045 <span class="comment">% Examples:</span>
0046 <span class="comment">%   s=[];</span>
0047 <span class="comment">%   s.populations(1).name='E';</span>
0048 <span class="comment">%   s.populations(1).equations='dv[2]/dt=@current+10; {iNa,iK}; v(0)=-65';</span>
0049 <span class="comment">%   s.populations(2).name='I';</span>
0050 <span class="comment">%   s.populations(2).equations='dv/dt=@current+10; {iNa,iK}; v(0)=-65';</span>
0051 <span class="comment">%   data=ds.simulateModel(s,'tspan',[0 1000]);</span>
0052 <span class="comment">%   data=ds.calcPower(data,'variable','v');</span>
0053 <span class="comment">%   % Plot the spectrum of the E-cell average population voltage</span>
0054 <span class="comment">%   figure; plot(data.E_v_Power_MUA.frequency,data.E_v_Power_MUA.Pxx);</span>
0055 <span class="comment">%   xlabel('frequency (Hz)'); ylabel('power'); xlim([0 200]);</span>
0056 <span class="comment">%</span>
0057 <span class="comment">% See also: PlotPower, AnalyzeStudy, ds.simulateModel, ds.checkData, ds.selectVariables</span>
0058 <span class="comment">%% 1.0 Check inputs</span>
0059 options=<a href="ds.checkOptions.html" class="code" title="function [parms, params_unspecified ] = ds.checkOptions(options, options_schema, strict)">ds.checkOptions</a>(varargin,{<span class="keyword">...</span>
0060   <span class="string">'variable'</span>,[],[],<span class="keyword">...</span>
0061   <span class="string">'time_limits'</span>,[-inf inf],[],<span class="keyword">...</span>
0062   <span class="string">'smooth_factor'</span>,5,[],<span class="keyword">...</span><span class="comment"> % number of samples for smoothing the spectrum</span>
0063   <span class="string">'min_peak_frequency'</span>,1,[],<span class="keyword">...</span><span class="comment"> % Hz, min frequency for peak detection</span>
0064   <span class="string">'max_peak_frequency'</span>,200,[],<span class="keyword">...</span><span class="comment"> % Hz, max frequency for peak detection</span>
0065   <span class="string">'peak_threshold_prctile'</span>,95,[],<span class="keyword">...</span><span class="comment"> % percentile for setting power threshold for peak detection</span>
0066   <span class="string">'peak_area_width'</span>,5,[],<span class="keyword">...</span><span class="comment"> % Hz, size of frequency bin (centered on peak) over which to calculate area under spectrum</span>
0067   <span class="string">'exclude_data_flag'</span>,0,{0,1},<span class="keyword">...</span>
0068   <span class="string">'timeBandwidthProduct'</span>,[],[],<span class="keyword">...</span><span class="comment"> % time-bandwidth product for multi-taper method</span>
0069   <span class="string">'output_suffix'</span>,<span class="string">''</span>,[],<span class="keyword">...</span>
0070   },false);
0071 
0072 data = <a href="ds.checkData.html" class="code" title="function data=ds.checkData(data)">ds.checkData</a>(data);
0073 <span class="comment">% note: calling ds.checkData() at beginning enables analysis function to</span>
0074 <span class="comment">% accept data matrix [time x cells] in addition to DynaSim data structure.</span>
0075 
0076 <span class="keyword">if</span> numel(data)&gt;1
0077   <span class="comment">% use AnalyzeStudy to recursively call ds.calcPower on each data set</span>
0078   data=<a href="AnalyzeStudy.html" class="code" title="function [results,studyinfo]=AnalyzeStudy(data,func,varargin)">AnalyzeStudy</a>(data,@<a href="ds.calcPower.html" class="code" title="function data = ds.calcPower(data,varargin)">ds.calcPower</a>,varargin{:});
0079   <span class="keyword">return</span>;
0080 <span class="keyword">end</span>
0081 
0082 <span class="comment">% time parameters</span>
0083 time = data.time; <span class="comment">% time vector</span>
0084 dt = time(2)-time(1); <span class="comment">% time step</span>
0085 <span class="comment">% ntime=length(time); % number of time points in full data set</span>
0086 t1=nearest(time,options.time_limits(1)); <span class="comment">% index to first sample</span>
0087 t2=nearest(time,options.time_limits(2)); <span class="comment">% index to last sample</span>
0088 nsamp=t2-t1+1; <span class="comment">% number of samples for spectral estimate</span>
0089 
0090 <span class="comment">% frequency parameters</span>
0091 Fs = fix(1/(dt/1000)); <span class="comment">% effective sampling frequency</span>
0092 Fmin=options.min_peak_frequency; <span class="comment">% min frequency for peak detection</span>
0093 Fmax=options.max_peak_frequency; <span class="comment">% max frequency for peak detection</span>
0094 thresh_prctile=options.peak_threshold_prctile; <span class="comment">% percentile for setting power threshold for peak detection</span>
0095 smooth_factor=options.smooth_factor; <span class="comment">% number of samples to smooth spectrum</span>
0096 Fwin=options.peak_area_width; <span class="comment">% size of frequency bin (centered on peak) for calculating area under spectrum</span>
0097 FreqRange=[max(Fmin,2/time(end)) Fmax]; <span class="comment">% range to look for spectral peaks</span>
0098 NFFT=2^(nextpow2(nsamp-1)-1);<span class="comment">%2); % &lt;-- use higher resolution to capture STO freq variation</span>
0099 <span class="comment">% WINDOW=2^(nextpow2(NFFT-1)-3);</span>
0100 <span class="comment">% NOVERLAP=[]; % spectral parameters</span>
0101 NW = options.timeBandwidthProduct;
0102 
0103 <span class="comment">%% 2.0 set list of variables to process as cell array of strings</span>
0104 options.variable=<a href="ds.selectVariables.html" class="code" title="function [variables,pop_names]=ds.selectVariables(labels,var_strings)">ds.selectVariables</a>(data(1).labels,options.variable);
0105 
0106 <span class="comment">%% 3.0 calculate power spectrum for each variable</span>
0107 <span class="keyword">if</span> ~isfield(data,<span class="string">'results'</span>)
0108   data.results={};
0109 <span class="keyword">end</span>
0110 
0111 warning off
0112 <span class="keyword">for</span> v=1:length(options.variable)
0113   <span class="comment">% extract this data set</span>
0114   var=options.variable{v};
0115   dat=data.(var);
0116   
0117   <span class="comment">% determine how many cells are in this data set</span>
0118   ncells=size(dat,2);
0119   
0120   <span class="comment">% preallocation</span>
0121   PeakFreq=nan(1,ncells);
0122   PeakArea=nan(1,ncells);
0123   
0124   <span class="comment">% SUA spectra: loop over cells</span>
0125   <span class="keyword">for</span> i=1:ncells
0126     <span class="comment">% select data</span>
0127     X=detrend(dat(t1:t2,i)); <span class="comment">% detrend the data</span>
0128     <span class="comment">% calculate spectral estimate</span>
0129     [tmpPxx,f] = pmtm(X, NW, NFFT, Fs); <span class="comment">% calculate power</span>
0130     
0131     <span class="keyword">if</span> i==1
0132       <span class="comment">% get size of spectrum and preallocate result matrix</span>
0133       nfreq=length(f);
0134       Pxx=nan(nfreq,ncells);
0135     <span class="keyword">end</span>
0136     
0137     <span class="keyword">if</span> all(isnan(tmpPxx(:)))
0138       tmpPxx=zeros(size(tmpPxx));
0139     <span class="keyword">end</span>
0140     
0141     <span class="keyword">if</span> ~isa(tmpPxx,<span class="string">'double'</span>)
0142       <span class="comment">% convert to double precision</span>
0143       tmpPxx=double(tmpPxx);
0144     <span class="keyword">end</span>
0145     
0146     <span class="keyword">if</span> smooth_factor&gt;1
0147       <span class="comment">% smooth the spectrum</span>
0148       tmpPxx=smooth(tmpPxx,smooth_factor);
0149     <span class="keyword">end</span>
0150     
0151     <span class="comment">% Peak Detection:</span>
0152     <span class="comment">% select range of frequencies over which to look for peaks</span>
0153     sel = find(FreqRange(1)&lt;=f &amp; f&lt;=FreqRange(end));
0154     
0155     <span class="comment">% set threshold for peak detection</span>
0156     ht=prctile(log10(tmpPxx(sel)),thresh_prctile);
0157     
0158     <span class="keyword">if</span> ~isnan(ht)
0159       <span class="comment">% get index of peaks in range over threshold</span>
0160       [PeakPower,PPind]=findpeaks(log10(tmpPxx(sel)),<span class="string">'MinPeakHeight'</span>,ht,<span class="string">'NPeaks'</span>,3);
0161     <span class="keyword">else</span>
0162       PPind=[];
0163     <span class="keyword">end</span>
0164     
0165     <span class="keyword">if</span> ~isempty(PPind)
0166       <span class="comment">% if multiple peaks, only consider the largest</span>
0167       <span class="keyword">if</span> numel(PPind)&gt;1
0168         PPind=PPind(max(PeakPower)==PeakPower); <span class="comment">%PPind=PPind(1);</span>
0169       <span class="keyword">end</span>
0170       
0171       <span class="comment">% get frequency at that index</span>
0172       PeakFreq(i) = f(sel(PPind));
0173       
0174       <span class="comment">% set limits for calculating area under spectrum around peak</span>
0175       flo=PeakFreq(i)-Fwin/2;
0176       fhi=PeakFreq(i)+Fwin/2;
0177       sel2=(flo&lt;=f &amp; f&lt;=fhi);
0178       <span class="comment">% calculate area under spectrum around peak</span>
0179       PeakArea(i) = sum(tmpPxx(sel2))*(f(2)-f(1));
0180     <span class="keyword">else</span>
0181       PeakFreq(i)=nan;
0182       PeakArea(i)=nan;
0183     <span class="keyword">end</span>
0184     <span class="comment">% Store results</span>
0185     Pxx(:,i)=tmpPxx;
0186   <span class="keyword">end</span>
0187   <span class="comment">% -----------------------------------------------------</span>
0188   <span class="comment">% Repeat spectral estimate for MUA:</span>
0189   <span class="keyword">if</span> ncells==1
0190     <span class="comment">% same as SUA</span>
0191     Pxx_mean=Pxx;
0192     Pxx_mean_PeakFreq=PeakFreq;
0193     Pxx_mean_PeakArea=PeakArea;
0194   <span class="keyword">else</span>
0195     <span class="comment">% calculate MUA</span>
0196     X=detrend(nanmean(dat(t1:t2,:),2)); <span class="comment">% detrend the data</span>
0197     
0198     <span class="comment">% calculate spectral estimate</span>
0199     [tmpPxx,f] = pwelch(X,NFFT,[],NFFT,Fs); <span class="comment">% calculate power</span>
0200     <span class="keyword">if</span> all(isnan(tmpPxx(:)))
0201       tmpPxx=zeros(size(tmpPxx));
0202     <span class="keyword">end</span>
0203     
0204     <span class="keyword">if</span> ~isa(tmpPxx,<span class="string">'double'</span>)
0205       <span class="comment">% convert to double precision</span>
0206       tmpPxx=double(tmpPxx);
0207     <span class="keyword">end</span>
0208     
0209     <span class="keyword">if</span> smooth_factor&gt;1
0210       <span class="comment">% smooth the spectrum</span>
0211       tmpPxx=smooth(tmpPxx,smooth_factor);
0212     <span class="keyword">end</span>
0213     
0214     <span class="comment">% Peak Detection:</span>
0215     <span class="comment">% select range of frequencies over which to look for peaks</span>
0216     sel = find(FreqRange(1)&lt;=f &amp; f&lt;=FreqRange(end));
0217     
0218     <span class="comment">% set threshold for peak detection</span>
0219     ht=prctile(log10(tmpPxx(sel)),thresh_prctile);
0220     <span class="keyword">if</span> ~isnan(ht)
0221       <span class="comment">% get index of peaks in range over threshold</span>
0222       [PeakPower,PPind]=findpeaks(log10(tmpPxx(sel)),<span class="string">'MinPeakHeight'</span>,ht,<span class="string">'NPeaks'</span>,3);
0223     <span class="keyword">else</span>
0224       PPind=[];
0225     <span class="keyword">end</span>
0226     
0227     <span class="keyword">if</span> ~isempty(PPind)
0228       <span class="comment">% if multiple peaks, only consider the largest</span>
0229       <span class="keyword">if</span> numel(PPind)&gt;1
0230         PPind=PPind(max(PeakPower)==PeakPower); <span class="comment">%PPind=PPind(1);</span>
0231       <span class="keyword">end</span>
0232       
0233       <span class="comment">% get frequency at that index</span>
0234       Pxx_mean_PeakFreq = f(sel(PPind));
0235       
0236       <span class="comment">% set limits for calculating area under spectrum around peak</span>
0237       flo=Pxx_mean_PeakFreq-Fwin/2;
0238       fhi=Pxx_mean_PeakFreq+Fwin/2;
0239       sel2=(flo&lt;=f &amp; f&lt;=fhi);
0240       
0241       <span class="comment">% calculate area under spectrum around peak</span>
0242       Pxx_mean_PeakArea = sum(tmpPxx(sel2))*(f(2)-f(1));
0243     <span class="keyword">else</span>
0244       Pxx_mean_PeakFreq=nan;
0245       Pxx_mean_PeakArea=nan;
0246     <span class="keyword">end</span>
0247     Pxx_mean=tmpPxx;
0248   <span class="keyword">end</span>
0249   
0250   <span class="comment">%% Add resulting power spectra to data structure</span>
0251   <span class="comment">% organization scheme:</span>
0252   <span class="comment">% data.VARIABLE_Power_SUA.(Pxx,PeakFreq,PeakArea,frequency)</span>
0253   <span class="comment">% data.VARIABLE_Power_MUA.(Pxx,PeakFreq,PeakArea,frequency)</span>
0254   data.([var <span class="string">'_Power_SUA'</span> options.output_suffix]).Pxx=Pxx;
0255   data.([var <span class="string">'_Power_SUA'</span> options.output_suffix]).PeakFreq=PeakFreq;
0256   data.([var <span class="string">'_Power_SUA'</span> options.output_suffix]).PeakArea=PeakArea;
0257   data.([var <span class="string">'_Power_SUA'</span> options.output_suffix]).frequency=f;
0258   data.([var <span class="string">'_Power_MUA'</span> options.output_suffix]).Pxx=Pxx_mean;
0259   data.([var <span class="string">'_Power_MUA'</span> options.output_suffix]).PeakFreq=Pxx_mean_PeakFreq;
0260   data.([var <span class="string">'_Power_MUA'</span> options.output_suffix]).PeakArea=Pxx_mean_PeakArea;
0261   data.([var <span class="string">'_Power_MUA'</span> options.output_suffix]).frequency=f;
0262   
0263   <span class="keyword">if</span> ~ismember([var <span class="string">'_Power_SUA'</span> options.output_suffix],data.results)
0264     data.results{end+1}=[var <span class="string">'_Power_SUA'</span> options.output_suffix];
0265   <span class="keyword">end</span>
0266   
0267   <span class="keyword">if</span> ~ismember([var <span class="string">'_Power_MUA'</span> options.output_suffix],data.results)
0268     data.results{end+1}=[var <span class="string">'_Power_MUA'</span> options.output_suffix];
0269   <span class="keyword">end</span>
0270   
0271   <span class="keyword">if</span> options.exclude_data_flag
0272     <span class="keyword">for</span> l=1:length(data.labels)
0273       data=rmfield(data,data.labels{l});
0274     <span class="keyword">end</span>
0275   <span class="keyword">end</span>
0276 <span class="comment">%   % alternate organization scheme:</span>
0277 <span class="comment">%   data.([var '_Pxx'])=Pxx;</span>
0278 <span class="comment">%   data.([var '_Pxx_PeakFreq'])=PeakFreq;</span>
0279 <span class="comment">%   data.([var '_Pxx_PeakArea'])=PeakArea;</span>
0280 <span class="comment">%   data.([var '_Pxx_mean'])=Pxx_mean;</span>
0281 <span class="comment">%   data.([var '_Pxx_mean_PeakFreq'])=Pxx_mean_PeakFreq;</span>
0282 <span class="comment">%   data.([var '_Pxx_mean_PeakArea'])=Pxx_mean_PeakArea;</span>
0283 <span class="comment">%   if ~ismember([var '_Pxx'],data.results)</span>
0284 <span class="comment">%     data.results{end+1}=[var '_Pxx'];</span>
0285 <span class="comment">%     data.results{end+1}=[var '_Pxx_PeakFreq'];</span>
0286 <span class="comment">%     data.results{end+1}=[var '_Pxx_PeakArea'];</span>
0287 <span class="comment">%     data.results{end+1}=[var '_Pxx_mean'];</span>
0288 <span class="comment">%     data.results{end+1}=[var '_Pxx_mean_Pxx_PeakFreq'];</span>
0289 <span class="comment">%     data.results{end+1}=[var '_Pxx_mean_Pxx_PeakArea'];</span>
0290 <span class="comment">%   end</span>
0291   
0292 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Fri 07-Apr-2017 20:01:20 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>