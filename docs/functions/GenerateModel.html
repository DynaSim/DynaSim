<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of ds.generateModel</title>
  <meta name="keywords" content="ds.generateModel">
  <meta name="description" content="GENERATEMODEL - Parse DynaSim specification and organize model data in DynaSim model structure">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- menu.html functions -->
<h1>ds.generateModel
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>GENERATEMODEL - Parse DynaSim specification and organize model data in DynaSim model structure</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function [model,name_map]=ds.generateModel(specification,varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment">GENERATEMODEL - Parse DynaSim specification and organize model data in DynaSim model structure

 Usage:
   [model,name_map]=ds.generateModel(specification,'option',value,...)

 Inputs:
   - specification: one of:
     - DynaSim specification structure (see below and ds.checkSpecification for more details)
     - string with name of MAT-file containing DynaSim specification structure
     - string with equations
     - string with name of file containing equations (.eqns)
       note: .eqns files can also be converted into model structure using LoadModel()
   - options (with defaults): 'option1',value1,'option2',value2,...
     'modifications'  : specify modifications to apply to specification
                        before generating the model, see ds.applyModifications
                        for more details (default?: []).
     'open_link_flag' : whether to leave linker identifiers in place (default: 0)

 Outputs:
   - model: DynaSim model structure (see ds.checkModel for more details):
     .parameters      : substructure with model parameters
     .fixed_variables : substructure with fixed variable definitions
     .functions       : substructure with function definitions
     .monitors        : substructure with monitor definitions
     .state_variables : cell array listing state variables
     .ODEs            : substructure with one ordinary differential
                             equation (ODE) per state variable
     .ICs             : substructure with initial conditions (ICs) for
                             each state variable
     .conditionals(i) : structure array with each element indicating
                             conditional actions specified in subfields
                             &quot;condition&quot;,&quot;action&quot;,&quot;else&quot; (see NOTE 1 in ds.checkModel)
     .linkers(i)      : structure array with each element indicating
                             an &quot;expression&quot; that should be inserted
                             (according to &quot;operation&quot;) into any equations
                             where the &quot;target&quot; appears. (see NOTE 2 in ds.checkModel)
       .target    : string giving the target where expression should be inserted
       .expression: string giving the expression to insert
       .operation : string giving the operation to use to insert expression
     .comments{i}     : cell array of comments found in model files
     .specification   : specification used to generate the model
     .namespaces      : (see NOTE 3 in ds.checkModel)
   - name_map: cell matrix mapping parameter, variable, and function names
       between the user-created specification (population equations and mechanism
       files) and the full model with automatically generated namespaces. It
       has four columns with: user-specified name, name with namespace prefix,
       namespace, and type ('parameters', 'fixed_variables', 'state_variables',
       'functions', or 'monitors') indicating the category to which the named
       element belongs.

 - DynaSim specification structure (see ds.checkSpecification for more details)
   .populations(i) (required): contains info for defining independent population models
       .name (default: 'pop1')      : name of population
       .size (default: 1)           : number of elements in population (i.e., # cells)
       .equations (required)        : string listing equations (see NOTE 1 in ds.checkSpecification)
       .mechanism_list (default: []): cell array listing mechanisms (see NOTE 2
                                      in ds.checkSpecification)
       .parameters (default: [])    : parameters to assign across all equations in
         the population. provide as cell array list of key/value pairs
         {'param1',value1,'param2',value2,...}
       .model (default: [])   : optional DynaSim model structure
   .connections(i) (default: []): contains info for linking population models
       .source (required if &gt;1 pops): name of source population
       .target (required if &gt;1 pops): name of target population
       .mechanism_list (required)   : list of mechanisms that link two populations
       .parameters (default: [])    : parameters to assign across all equations in
         mechanisms of this connection's mechanism_list.

 Examples:
   - Example 0:
     model=ds.generateModel('db/dt=3')

   - Example 1: Lorenz equations
     eqns={
       's=10; r=27; b=2.666';
       'dx/dt=s*(y-x)';
       'dy/dt=r*x-y-x*z';
       'dz/dt=-b*z+x*y';
     };
     model=ds.generateModel(eqns)

   - Example 2: Leaky integrate-and-fire neuron
     model=ds.generateModel('tau=10; R=10; E=-70; dV/dt=(E-V+R*1.55)/tau; if(V&gt;-55)(V=-75)')

   - Example 3: Hodgkin-Huxley neuron with sinusoidal drive
     model=ds.generateModel('dv/dt=current+sin(2*pi*t); {iNa,iK}')

   - Example 4: HH with self inhibition and sinusoidal drive
     specification.populations(1).equations='dv/dt=current+sin(2*pi); v(0)=-65';
     specification.populations(1).mechanism_list={'iNa','iK'};
     specification.connections(1).mechanism_list={'iGABAa'};
     specification.connections(1).parameters={'tauDx',15};
     model=ds.generateModel(specification)

   - Example 5: using custom mechanism alias in equations (for modularization)
     specification.populations(1).equations='dv/dt=@M+sin(2*pi); v(0)=-65';
     specification.populations(1).mechanism_list={'iNa@M','iK@M'};
     model=ds.generateModel(specification)

     or:

     specification.populations(1).equations='dv/dt=@M+sin(2*pi); {iNa,iK}@M; v(0)=-65';
     model=ds.generateModel(specification)

   - Example 6: directly incorporating mechanism models from online repositories:

     model=ds.generateModel('dv/dt=@M; {ib:57,iK}@M')

     where &quot;ib&quot; is a known alias for the infinitebrain.org repository,
     and &quot;57&quot; is the Na+ current at http://infinitebrain.org/models/57.
     note: currently not supported on *most* machines...

 See also: <a href="ds.checkSpecification.html" class="code" title="function spec=ds.checkSpecification(specification)">ds.checkSpecification</a>, <a href="ds.checkModel.html" class="code" title="function model=ds.checkModel(model)">ds.checkModel</a>, <a href="ds.parseModelEquations.html" class="code" title="function [model,name_map] = ds.parseModelEquations(text,varargin)">ds.parseModelEquations</a>, <a href="ds.simulateModel.html" class="code" title="function [data,studyinfo]=ds.simulateModel(model,varargin)">ds.simulateModel</a></pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="ds.applyModifications.html" class="code" title="function [output,modifications]=ds.applyModifications(model,modifications)">ds.applyModifications</a>	APPLYMODIFICATIONS - Apply modifications to DynaSim specification or model structure</li><li><a href="ds.checkModel.html" class="code" title="function model=ds.checkModel(model)">ds.checkModel</a>	CHECKMODEL - Standardize model structure and auto-populate missing fields</li><li><a href="ds.checkOptions.html" class="code" title="function [parms, params_unspecified ] = ds.checkOptions(options, options_schema, strict)">ds.checkOptions</a>	CHECKOPTIONS - organize key/value pairs in structure with default or user-supplied values according to a schema</li><li><a href="ds.checkSpecification.html" class="code" title="function spec=ds.checkSpecification(specification)">ds.checkSpecification</a>	CHECKSPECIFICATION - standardize specification structure and auto-populate missing fields</li><li><a href="ds.combineModels.html" class="code" title="function model=ds.combineModels(model1,model2)">ds.combineModels</a>	COMBINEMODELS - combine subfields in two DynaSim model structures</li><li><a href="ds.importModel.html" class="code" title="function [model,map] = ds.importModel(source,varargin)">ds.importModel</a>	IMPORTMODEL - import model from raw equations, other program source, etc.</li><li><a href="ds.propagateNamespaces.html" class="code" title="function model = ds.propagateNamespaces(model,map)">ds.propagateNamespaces</a>	PROPAGATENAMESPACES - namespace-establishing namespace substitutions.</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="ds.applyModifications.html" class="code" title="function [output,modifications]=ds.applyModifications(model,modifications)">ds.applyModifications</a>	APPLYMODIFICATIONS - Apply modifications to DynaSim specification or model structure</li><li><a href="ds.checkModel.html" class="code" title="function model=ds.checkModel(model)">ds.checkModel</a>	CHECKMODEL - Standardize model structure and auto-populate missing fields</li><li><a href="ds.probeCellProperties.html" class="code" title="function data = ds.probeCellProperties(model,varargin)">ds.probeCellProperties</a>	data = ds.probeCellProperties(model,'option1',option1,...)</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="#_sub1" class="code">function_names=fieldnames(model.functions);</a></li><li><a href="#_sub2" class="code">function_names={};</a></li><li><a href="#_sub3" class="code">function_monitor_index=find(~cellfun(@isempty,regexp(monitor_names,</a></li><li><a href="#_sub4" class="code">functions_to_monitor={};</a></li><li><a href="#_sub5" class="code">function_index=find(~cellfun(@isempty,regexp(function_names,[</a></li><li><a href="#_sub6" class="code">functions_to_monitor=cat(1,functions_to_monitor,function_names(function_index));</a></li><li><a href="#_sub7" class="code">functions_to_monitor=unique(functions_to_monitor);</a></li><li><a href="#_sub8" class="code">function add_keywords(src,dst,namespace)</a></li><li><a href="#_sub9" class="code">function_names=fieldnames(model.functions);</a></li><li><a href="#_sub10" class="code">function str=linker_strrep(str,oldstr,newstr,operator)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [model,name_map]=ds.generateModel(specification,varargin)</a>
0002 <span class="comment">%GENERATEMODEL - Parse DynaSim specification and organize model data in DynaSim model structure</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% Usage:</span>
0005 <span class="comment">%   [model,name_map]=ds.generateModel(specification,'option',value,...)</span>
0006 <span class="comment">%</span>
0007 <span class="comment">% Inputs:</span>
0008 <span class="comment">%   - specification: one of:</span>
0009 <span class="comment">%     - DynaSim specification structure (see below and ds.checkSpecification for more details)</span>
0010 <span class="comment">%     - string with name of MAT-file containing DynaSim specification structure</span>
0011 <span class="comment">%     - string with equations</span>
0012 <span class="comment">%     - string with name of file containing equations (.eqns)</span>
0013 <span class="comment">%       note: .eqns files can also be converted into model structure using LoadModel()</span>
0014 <span class="comment">%   - options (with defaults): 'option1',value1,'option2',value2,...</span>
0015 <span class="comment">%     'modifications'  : specify modifications to apply to specification</span>
0016 <span class="comment">%                        before generating the model, see ds.applyModifications</span>
0017 <span class="comment">%                        for more details (default?: []).</span>
0018 <span class="comment">%     'open_link_flag' : whether to leave linker identifiers in place (default: 0)</span>
0019 <span class="comment">%</span>
0020 <span class="comment">% Outputs:</span>
0021 <span class="comment">%   - model: DynaSim model structure (see ds.checkModel for more details):</span>
0022 <span class="comment">%     .parameters      : substructure with model parameters</span>
0023 <span class="comment">%     .fixed_variables : substructure with fixed variable definitions</span>
0024 <span class="comment">%     .functions       : substructure with function definitions</span>
0025 <span class="comment">%     .monitors        : substructure with monitor definitions</span>
0026 <span class="comment">%     .state_variables : cell array listing state variables</span>
0027 <span class="comment">%     .ODEs            : substructure with one ordinary differential</span>
0028 <span class="comment">%                             equation (ODE) per state variable</span>
0029 <span class="comment">%     .ICs             : substructure with initial conditions (ICs) for</span>
0030 <span class="comment">%                             each state variable</span>
0031 <span class="comment">%     .conditionals(i) : structure array with each element indicating</span>
0032 <span class="comment">%                             conditional actions specified in subfields</span>
0033 <span class="comment">%                             &quot;condition&quot;,&quot;action&quot;,&quot;else&quot; (see NOTE 1 in ds.checkModel)</span>
0034 <span class="comment">%     .linkers(i)      : structure array with each element indicating</span>
0035 <span class="comment">%                             an &quot;expression&quot; that should be inserted</span>
0036 <span class="comment">%                             (according to &quot;operation&quot;) into any equations</span>
0037 <span class="comment">%                             where the &quot;target&quot; appears. (see NOTE 2 in ds.checkModel)</span>
0038 <span class="comment">%       .target    : string giving the target where expression should be inserted</span>
0039 <span class="comment">%       .expression: string giving the expression to insert</span>
0040 <span class="comment">%       .operation : string giving the operation to use to insert expression</span>
0041 <span class="comment">%     .comments{i}     : cell array of comments found in model files</span>
0042 <span class="comment">%     .specification   : specification used to generate the model</span>
0043 <span class="comment">%     .namespaces      : (see NOTE 3 in ds.checkModel)</span>
0044 <span class="comment">%   - name_map: cell matrix mapping parameter, variable, and function names</span>
0045 <span class="comment">%       between the user-created specification (population equations and mechanism</span>
0046 <span class="comment">%       files) and the full model with automatically generated namespaces. It</span>
0047 <span class="comment">%       has four columns with: user-specified name, name with namespace prefix,</span>
0048 <span class="comment">%       namespace, and type ('parameters', 'fixed_variables', 'state_variables',</span>
0049 <span class="comment">%       'functions', or 'monitors') indicating the category to which the named</span>
0050 <span class="comment">%       element belongs.</span>
0051 <span class="comment">%</span>
0052 <span class="comment">% - DynaSim specification structure (see ds.checkSpecification for more details)</span>
0053 <span class="comment">%   .populations(i) (required): contains info for defining independent population models</span>
0054 <span class="comment">%       .name (default: 'pop1')      : name of population</span>
0055 <span class="comment">%       .size (default: 1)           : number of elements in population (i.e., # cells)</span>
0056 <span class="comment">%       .equations (required)        : string listing equations (see NOTE 1 in ds.checkSpecification)</span>
0057 <span class="comment">%       .mechanism_list (default: []): cell array listing mechanisms (see NOTE 2</span>
0058 <span class="comment">%                                      in ds.checkSpecification)</span>
0059 <span class="comment">%       .parameters (default: [])    : parameters to assign across all equations in</span>
0060 <span class="comment">%         the population. provide as cell array list of key/value pairs</span>
0061 <span class="comment">%         {'param1',value1,'param2',value2,...}</span>
0062 <span class="comment">%       .model (default: [])   : optional DynaSim model structure</span>
0063 <span class="comment">%   .connections(i) (default: []): contains info for linking population models</span>
0064 <span class="comment">%       .source (required if &gt;1 pops): name of source population</span>
0065 <span class="comment">%       .target (required if &gt;1 pops): name of target population</span>
0066 <span class="comment">%       .mechanism_list (required)   : list of mechanisms that link two populations</span>
0067 <span class="comment">%       .parameters (default: [])    : parameters to assign across all equations in</span>
0068 <span class="comment">%         mechanisms of this connection's mechanism_list.</span>
0069 <span class="comment">%</span>
0070 <span class="comment">% Examples:</span>
0071 <span class="comment">%   - Example 0:</span>
0072 <span class="comment">%     model=ds.generateModel('db/dt=3')</span>
0073 <span class="comment">%</span>
0074 <span class="comment">%   - Example 1: Lorenz equations</span>
0075 <span class="comment">%     eqns={</span>
0076 <span class="comment">%       's=10; r=27; b=2.666';</span>
0077 <span class="comment">%       'dx/dt=s*(y-x)';</span>
0078 <span class="comment">%       'dy/dt=r*x-y-x*z';</span>
0079 <span class="comment">%       'dz/dt=-b*z+x*y';</span>
0080 <span class="comment">%     };</span>
0081 <span class="comment">%     model=ds.generateModel(eqns)</span>
0082 <span class="comment">%</span>
0083 <span class="comment">%   - Example 2: Leaky integrate-and-fire neuron</span>
0084 <span class="comment">%     model=ds.generateModel('tau=10; R=10; E=-70; dV/dt=(E-V+R*1.55)/tau; if(V&gt;-55)(V=-75)')</span>
0085 <span class="comment">%</span>
0086 <span class="comment">%   - Example 3: Hodgkin-Huxley neuron with sinusoidal drive</span>
0087 <span class="comment">%     model=ds.generateModel('dv/dt=current+sin(2*pi*t); {iNa,iK}')</span>
0088 <span class="comment">%</span>
0089 <span class="comment">%   - Example 4: HH with self inhibition and sinusoidal drive</span>
0090 <span class="comment">%     specification.populations(1).equations='dv/dt=current+sin(2*pi); v(0)=-65';</span>
0091 <span class="comment">%     specification.populations(1).mechanism_list={'iNa','iK'};</span>
0092 <span class="comment">%     specification.connections(1).mechanism_list={'iGABAa'};</span>
0093 <span class="comment">%     specification.connections(1).parameters={'tauDx',15};</span>
0094 <span class="comment">%     model=ds.generateModel(specification)</span>
0095 <span class="comment">%</span>
0096 <span class="comment">%   - Example 5: using custom mechanism alias in equations (for modularization)</span>
0097 <span class="comment">%     specification.populations(1).equations='dv/dt=@M+sin(2*pi); v(0)=-65';</span>
0098 <span class="comment">%     specification.populations(1).mechanism_list={'iNa@M','iK@M'};</span>
0099 <span class="comment">%     model=ds.generateModel(specification)</span>
0100 <span class="comment">%</span>
0101 <span class="comment">%     or:</span>
0102 <span class="comment">%</span>
0103 <span class="comment">%     specification.populations(1).equations='dv/dt=@M+sin(2*pi); {iNa,iK}@M; v(0)=-65';</span>
0104 <span class="comment">%     model=ds.generateModel(specification)</span>
0105 <span class="comment">%</span>
0106 <span class="comment">%   - Example 6: directly incorporating mechanism models from online repositories:</span>
0107 <span class="comment">%</span>
0108 <span class="comment">%     model=ds.generateModel('dv/dt=@M; {ib:57,iK}@M')</span>
0109 <span class="comment">%</span>
0110 <span class="comment">%     where &quot;ib&quot; is a known alias for the infinitebrain.org repository,</span>
0111 <span class="comment">%     and &quot;57&quot; is the Na+ current at http://infinitebrain.org/models/57.</span>
0112 <span class="comment">%     note: currently not supported on *most* machines...</span>
0113 <span class="comment">%</span>
0114 <span class="comment">% See also: ds.checkSpecification, ds.checkModel, ds.parseModelEquations, ds.simulateModel</span>
0115 
0116 <span class="comment">% Check inputs</span>
0117 <span class="comment">% ------------------------------------------------------</span>
0118 <span class="keyword">if</span> nargin==0
0119   <span class="comment">% use default model</span>
0120   specification=[];
0121   specification.populations(1).equations=<span class="string">'dv/dt=10+@current/Cm; Cm=1; v(0)=-65'</span>;
0122   specification.populations(1).mechanism_list={<span class="string">'iNa'</span>,<span class="string">'iK'</span>};
0123   specification.populations(1).parameters={<span class="string">'Cm'</span>,1};
0124   specification.connections(1).mechanism_list={<span class="string">'iGABAa'</span>};
0125   varargin={<span class="string">'modifications'</span>,[]};
0126 <span class="keyword">end</span>
0127 <span class="comment">% ------------------------------------------------------</span>
0128 
0129 options=<a href="ds.checkOptions.html" class="code" title="function [parms, params_unspecified ] = ds.checkOptions(options, options_schema, strict)">ds.checkOptions</a>(varargin,{<span class="keyword">...</span>
0130   <span class="string">'modifications'</span>,[],[],<span class="keyword">...</span>
0131   <span class="string">'open_link_flag'</span>,0,{0,1},<span class="keyword">...</span>
0132   },false);
0133 <span class="comment">% check if a model</span>
0134 <span class="keyword">if</span> isfield(specification,<span class="string">'state_variables'</span>)
0135   <span class="comment">% do nothing</span>
0136   model=specification;
0137   <span class="keyword">return</span>;
0138 <span class="comment">%   TODO: consider the following --</span>
0139 <span class="comment">%   if isfield(specification,'specification')</span>
0140 <span class="comment">%     % regenerate from specification</span>
0141 <span class="comment">%     specification=specification.specification;</span>
0142 <span class="comment">%   end</span>
0143 <span class="keyword">end</span>
0144 <span class="comment">% standardize specification</span>
0145 specification=<a href="ds.checkSpecification.html" class="code" title="function spec=ds.checkSpecification(specification)">ds.checkSpecification</a>(specification); <span class="comment">% standardize &amp; auto-populate as needed</span>
0146 
0147 <span class="comment">% Apply modifications to specification before generating model</span>
0148 <span class="keyword">if</span> ~isempty(options.modifications)
0149   specification=<a href="ds.applyModifications.html" class="code" title="function [output,modifications]=ds.applyModifications(model,modifications)">ds.applyModifications</a>(specification,options.modifications);
0150 <span class="keyword">end</span>
0151 
0152 <span class="comment">% specification metadata:</span>
0153 npops=length(specification.populations); <span class="comment">% number of populations</span>
0154 ncons=length(specification.connections); <span class="comment">% number of connections</span>
0155 
0156 <span class="comment">%{</span>
0157 <span class="comment">% Dev notes on improving implementation:</span>
0158 <span class="comment">% Ideally (1.0)-(3.0) could be packaged into external functions and run as:</span>
0159 <span class="comment">% -------------------------------------------------------------------------</span>
0160 <span class="comment">%% 1.0 load sub-models, assign namespaces, and combine across all equations and mechanisms in specification</span>
0161 <span class="comment">% [model,name_map]=LoadModelSet(specification) % bug: disrupted subsequent namespace propagation (without raising an error)</span>
0162 <span class="comment">%% 2.0 propagate namespaces through variable and function names</span>
0163 <span class="comment">% model = ds.propagateNamespaces(model,name_map); % this works</span>
0164 <span class="comment">%% 3.0 expand population equations according to mechanism linkers</span>
0165 <span class="comment">% model = LinkMechanisms(model,name_map);      % problem: unable to identify linker population from model.linkers; see notes below (3.0) for more details</span>
0166 <span class="comment">% -------------------------------------------------------------------------</span>
0167 <span class="comment">%}</span>
0168 
0169 <span class="comment">% support full modularization of mechanisms</span>
0170 <span class="comment">% (eg, dv/dt=@M; {Na,K}@M w/ Na.mech: @current += I(IN,m,h)).</span>
0171 <span class="comment">%     approach taken below:</span>
0172 <span class="comment">%     - add support for dv/dt=@M; {Na@M,K@M}</span>
0173 <span class="comment">%       have ds.generateModel split mech_name on '@' and replace first</span>
0174 <span class="comment">%       linker in mech (e.g., @current) by what follows '@' (e.g., @M)</span>
0175 <span class="comment">%     - then have ds.checkSpecification convert {Na,K}@M into {Na@M,K@M}</span>
0176 
0177 <span class="comment">%% 1.0 load sub-models, assign namespaces, and combine across all equations and mechanisms in specification</span>
0178 model.parameters={};
0179 model.fixed_variables=[];
0180 model.functions=[];
0181 model.monitors=[];
0182 model.state_variables={};
0183 model.ODEs=[];
0184 model.ICs=[];
0185 model.conditionals=[];
0186 model.linkers=[];
0187 model.comments={};
0188 name_map={}; <span class="comment">% {name, namespace_name, namespace, type}, used for namespacing</span>
0189 linker_pops={}; <span class="comment">% list of populations associated with mechanism linkers</span>
0190 
0191 <span class="comment">% 1.1 load and combine population sub-models from population equations and mechanisms</span>
0192 <span class="keyword">for</span> i=1:npops
0193   <span class="comment">% does the population model already exist?</span>
0194   <span class="keyword">if</span> ~isempty(specification.populations(i).model)
0195     tmpmodel=specification.populations(i).model; <span class="comment">% get model structure</span>
0196     tmpname=tmpmodel.specification.populations.name; <span class="comment">% assumes one population sub-model</span>
0197     
0198     <span class="comment">% adjust the name if necessary</span>
0199     <span class="keyword">if</span> ~strcmp(specification.populations(i).name,tmpname)
0200       <span class="comment">% use the name in the specification</span>
0201       tmpmodel=<a href="ds.applyModifications.html" class="code" title="function [output,modifications]=ds.applyModifications(model,modifications)">ds.applyModifications</a>(tmpmodel,{tmpname,<span class="string">'name'</span>,specification.populations(i).name});
0202     <span class="keyword">elseif</span> strcmp(tmpname,<span class="string">'pop1'</span>) <span class="comment">% if default name</span>
0203       <span class="comment">% use default name for this population index</span>
0204       tmpmodel=<a href="ds.applyModifications.html" class="code" title="function [output,modifications]=ds.applyModifications(model,modifications)">ds.applyModifications</a>(tmpmodel,{tmpname,<span class="string">'name'</span>,sprintf(<span class="string">'pop%g'</span>,i)});
0205     <span class="keyword">end</span>
0206     
0207     tmpmodel.linkers=[]; <span class="comment">% remove old linkers from original model construction</span>
0208     model=<a href="ds.combineModels.html" class="code" title="function model=ds.combineModels(model1,model2)">ds.combineModels</a>(model,tmpmodel);
0209     name_map=<a href="#_sub6" class="code" title="subfunctions_to_monitor=cat(1,functions_to_monitor,function_names(function_index));">cat</a>(1,name_map,tmpmodel.namespaces);
0210     <span class="keyword">continue</span>;
0211   <span class="keyword">end</span>
0212   <span class="comment">% construct new population model</span>
0213   PopScope=specification.populations(i).name;
0214     <span class="comment">% NOTE: ds.parseModelEquations adds a '_' suffix to the namespace; therefore,</span>
0215     <span class="comment">% a '_' suffix is added to PopScope when used below for consistency of</span>
0216     <span class="comment">% namespaces/namespaces. (this could be cleaned up by adding '_' to PopScope</span>
0217     <span class="comment">% here, removing it below, and removing the additional '_' from</span>
0218     <span class="comment">% ds.parseModelEquations).</span>
0219     
0220   <span class="comment">% 1.1.1 parse population equations</span>
0221   equations=specification.populations(i).equations;
0222   parameters=specification.populations(i).parameters;
0223   nmechs=length(specification.populations(i).mechanism_list);
0224   
0225   <span class="comment">% parse population equations</span>
0226   <span class="keyword">if</span> ~isempty(equations)
0227     [tmpmodel,tmpmap]=<a href="ds.importModel.html" class="code" title="function [model,map] = ds.importModel(source,varargin)">ds.importModel</a>(equations,<span class="string">'namespace'</span>,PopScope,<span class="string">'ic_pop'</span>,specification.populations(i).name,<span class="string">'user_parameters'</span>,parameters);
0228     model=<a href="ds.combineModels.html" class="code" title="function model=ds.combineModels(model1,model2)">ds.combineModels</a>(model,tmpmodel);
0229     name_map=<a href="#_sub6" class="code" title="subfunctions_to_monitor=cat(1,functions_to_monitor,function_names(function_index));">cat</a>(1,name_map,tmpmap);
0230   <span class="keyword">end</span>
0231   
0232   <span class="comment">% 1.1.2 parse population mechanisms</span>
0233   <span class="keyword">for</span> j=1:nmechs
0234     mechanism_=specification.populations(i).mechanism_list{j};
0235     
0236     <span class="comment">% support separation of linker names in pop equations vs mechanisms</span>
0237     mechanism_=regexp(mechanism_,<span class="string">'@'</span>,<span class="string">'split'</span>);
0238     mechanism=mechanism_{1};
0239     
0240     <span class="keyword">if</span> numel(mechanism_)&gt;1, new_linker=mechanism_{2}; <span class="keyword">else</span> new_linker=[]; <span class="keyword">end</span>
0241     
0242     <span class="comment">% set mechanism namespace</span>
0243     <span class="keyword">if</span> any(mechanism==<span class="string">':'</span>)
0244       <span class="comment">% exclude host name from namespace</span>
0245       tmp=regexp(mechanism,<span class="string">':'</span>,<span class="string">'split'</span>);
0246       MechScope=[specification.populations(i).name <span class="string">'_'</span> tmp{2}];
0247     <span class="keyword">else</span>
0248       <span class="comment">% extract mechanism file name without path</span>
0249       [~,MechID]=fileparts(mechanism);
0250       MechScope=[specification.populations(i).name <span class="string">'_'</span> MechID];
0251     <span class="keyword">end</span>
0252 
0253     <span class="comment">% parse mechanism equations</span>
0254     [tmpmodel,tmpmap]=<a href="ds.importModel.html" class="code" title="function [model,map] = ds.importModel(source,varargin)">ds.importModel</a>(mechanism,<span class="string">'namespace'</span>,MechScope,<span class="string">'ic_pop'</span>,specification.populations(i).name,<span class="string">'user_parameters'</span>,parameters);
0255     <span class="comment">% replace 1st linker name by the one in specification</span>
0256     <span class="keyword">if</span> ~isempty(new_linker) &amp;&amp; ~isempty(tmpmodel.linkers)
0257       <span class="comment">% first try to find 1st linker target starting with @</span>
0258       links_at=<a href="#_sub3  5" class="code" title="subfunction_monitor_index=find(~cellfun(@isempty,regexp(monitor_names,function_index=find(~cellfun(@isempty,regexp(function_names,[">find</a>(~cellfun(@isempty,regexp({tmpmodel.linkers.target},<span class="string">'^@'</span>,<span class="string">'once'</span>)));
0259       
0260       <span class="keyword">if</span> ~isempty(links_at)
0261         <span class="comment">% use first link with target prepended by '@'</span>
0262         link_ind=links_at(1);
0263       <span class="keyword">else</span>
0264         <span class="comment">% use first link</span>
0265         link_ind=1;
0266       <span class="keyword">end</span>
0267       
0268       tmpmodel.linkers(link_ind).target=[<span class="string">'@'</span> new_linker];
0269     <span class="keyword">end</span>
0270     
0271     <span class="comment">% combine sub-model with other sub-models</span>
0272     model=<a href="ds.combineModels.html" class="code" title="function model=ds.combineModels(model1,model2)">ds.combineModels</a>(model,tmpmodel);
0273     name_map=<a href="#_sub6" class="code" title="subfunctions_to_monitor=cat(1,functions_to_monitor,function_names(function_index));">cat</a>(1,name_map,tmpmap);
0274     linker_pops=<a href="#_sub6" class="code" title="subfunctions_to_monitor=cat(1,functions_to_monitor,function_names(function_index));">cat</a>(2,linker_pops,repmat({specification.populations(i).name},[1 length(tmpmodel.linkers)]));
0275   <span class="keyword">end</span>
0276   pop=specification.populations(i).name;
0277   
0278   <span class="comment">% add reserved keywords (parameters and state variables) to name_map</span>
0279   <a href="#_sub8" class="code" title="subfunction add_keywords(src,dst,namespace)">add_keywords</a>(pop,pop,[PopScope <span class="string">'_'</span>]);
0280   model.parameters.([pop <span class="string">'_Npop'</span>])=num2str(specification.populations(i).size);
0281 <span class="keyword">end</span>
0282 
0283 <span class="comment">% 1.2 load and combine sub-models from connection mechanisms</span>
0284 <span class="keyword">for</span> i=1:ncons
0285   <span class="comment">% parse connection mechanisms</span>
0286   source=specification.connections(i).source;
0287   target=specification.connections(i).target;
0288   parameters=specification.connections(i).parameters;
0289   ConScope=[target <span class="string">'_'</span> source <span class="string">'_'</span>];
0290     <span class="comment">% NOTE: in contrast to PopScope above, ConScope is never passed to</span>
0291     <span class="comment">% ds.parseModelEquations; thus the '_' should be added here for consistency</span>
0292     <span class="comment">% with mechanism namespaces (which are modified by ds.parseModelEquations).</span>
0293   <span class="keyword">for</span> j=1:length(specification.connections(i).mechanism_list)
0294     mechanism_=specification.connections(i).mechanism_list{j};
0295     
0296     <span class="comment">% support separation of linker names in pop equations vs mechanisms</span>
0297     mechanism_=regexp(mechanism_,<span class="string">'@'</span>,<span class="string">'split'</span>);
0298     mechanism=mechanism_{1};
0299     
0300     <span class="keyword">if</span> numel(mechanism_)&gt;1, new_linker=mechanism_{2}; <span class="keyword">else</span> new_linker=[]; <span class="keyword">end</span>
0301     
0302     <span class="comment">% extract mechanism file name without path</span>
0303     [~,MechID]=fileparts(mechanism);
0304     MechScope=[target <span class="string">'_'</span> source <span class="string">'_'</span> MechID];
0305         <span class="comment">% NOTE: must use target_source_mechanism for connection mechanisms</span>
0306         <span class="comment">% to distinguish their parent namespaces from those of population mechanisms</span>
0307         <span class="comment">% see: ds.getParentNamespace</span>
0308     
0309     <span class="comment">% parse model equations</span>
0310     [tmpmodel,tmpmap]=<a href="ds.importModel.html" class="code" title="function [model,map] = ds.importModel(source,varargin)">ds.importModel</a>(mechanism,<span class="string">'namespace'</span>,MechScope,<span class="string">'ic_pop'</span>,source,<span class="string">'user_parameters'</span>,parameters);
0311     
0312     <span class="comment">% replace 1st linker name by the one in specification</span>
0313     <span class="keyword">if</span> ~isempty(new_linker) &amp;&amp; ~isempty(tmpmodel.linkers)
0314       tmpmodel.linkers(1).target=[<span class="string">'@'</span> new_linker];
0315     <span class="keyword">end</span>
0316     
0317     model=<a href="ds.combineModels.html" class="code" title="function model=ds.combineModels(model1,model2)">ds.combineModels</a>(model,tmpmodel);
0318     name_map=<a href="#_sub6" class="code" title="subfunctions_to_monitor=cat(1,functions_to_monitor,function_names(function_index));">cat</a>(1,name_map,tmpmap);
0319     
0320     <span class="comment">% link this mechanism to the target population</span>
0321     linker_pops=<a href="#_sub6" class="code" title="subfunctions_to_monitor=cat(1,functions_to_monitor,function_names(function_index));">cat</a>(2,linker_pops,repmat(target,[1 length(tmpmodel.linkers)]));
0322     
0323     <span class="comment">% edit names of connection monitors specified in population equations</span>
0324     <span class="comment">% TODO: consider design changes to avoid specifying connection monitors</span>
0325     <span class="comment">%   in population equations; this is an undesirable hack:</span>
0326     <span class="comment">%     eg, convert E_iGABAa_functions -&gt; I_E_iGABAa_functions</span>
0327     <span class="keyword">if</span> ~isempty(model.monitors)
0328       <span class="comment">% get indices to all model.monitors that have incorrect connection namespace</span>
0329       con_mon_to_update=<a href="#_sub3  5" class="code" title="subfunction_monitor_index=find(~cellfun(@isempty,regexp(monitor_names,function_index=find(~cellfun(@isempty,regexp(function_names,[">find</a>(~cellfun(@isempty,regexp(<a href="#_sub1  9" class="code" title="subfunction_names=fieldnames(model.functions);function_names=fieldnames(model.functions);">fieldnames</a>(model.monitors),[<span class="string">'^'</span> target <span class="string">'_'</span> mechanism])));
0330       <span class="keyword">if</span> any(con_mon_to_update)
0331         <span class="comment">% get list of current model.monitors</span>
0332         monitor_names=<a href="#_sub1  9" class="code" title="subfunction_names=fieldnames(model.functions);function_names=fieldnames(model.functions);">fieldnames</a>(model.monitors);
0333         <span class="keyword">for</span> m=1:length(con_mon_to_update)
0334           <span class="comment">% get name of monitor with incorrect connection namespace</span>
0335           old=monitor_names{con_mon_to_update(m)};
0336           
0337           <span class="comment">% get name of monitor with correct connection namespace</span>
0338           new=strrep(old,[target <span class="string">'_'</span> mechanism <span class="string">'_'</span>],[MechScope <span class="string">'_'</span>]);
0339           
0340           <span class="comment">% add new monitor with correct namespace</span>
0341           model.monitors.(new)=model.monitors.(old);
0342           
0343           <span class="comment">% remove old monitor with incorrect namespace</span>
0344           model.monitors=rmfield(model.monitors,old);
0345         <span class="keyword">end</span>
0346       <span class="keyword">end</span>
0347     <span class="keyword">end</span>
0348   <span class="keyword">end</span>
0349   <span class="comment">% add reserved keywords (parameters and state variables) to name_map</span>
0350   <a href="#_sub8" class="code" title="subfunction add_keywords(src,dst,namespace)">add_keywords</a>(source,target,ConScope);
0351 <span class="keyword">end</span>
0352 
0353 <span class="comment">% check for monitoring functions (e.g., 'monitor functions' or 'monitor Na.functions')</span>
0354 <span class="keyword">if</span> ~isempty(model.monitors)
0355   <span class="comment">% get list of functions</span>
0356   <span class="keyword">if</span> ~isempty(model.functions)
0357     <a name="_sub1" href="#_subfunctions" class="code">function_names=fieldnames(model.functions);</a>
0358   <span class="keyword">else</span>
0359     <a name="_sub2" href="#_subfunctions" class="code">function_names={};</a>
0360   <span class="keyword">end</span>
0361   <span class="comment">% get list of monitor names</span>
0362   monitor_names=<a href="#_sub1  9" class="code" title="subfunction_names=fieldnames(model.functions);function_names=fieldnames(model.functions);">fieldnames</a>(model.monitors);
0363   
0364   <span class="comment">% get indices to monitors with names ending in _functions</span>
0365   <a name="_sub3" href="#_subfunctions" class="code">function_monitor_index=find(~cellfun(@isempty,regexp(monitor_names,</a><span class="string">'_functions$'</span>,<span class="string">'once'</span>)));
0366   
0367   <span class="comment">% create list of functions with namespaces matching monitors ending in _functions</span>
0368   <a name="_sub4" href="#_subfunctions" class="code">functions_to_monitor={};</a>
0369   
0370   <span class="keyword">for</span> i=1:length(function_monitor_index)
0371     <span class="comment">% get namespace of functions to monitor</span>
0372     monitor_name=monitor_names{function_monitor_index(i)};
0373     monitor_namespace=regexp(monitor_name,<span class="string">'(.*)_functions$'</span>,<span class="string">'tokens'</span>,<span class="string">'once'</span>);
0374     monitor_namespace=monitor_namespace{1};
0375     
0376     <span class="comment">% get list of functions with matching namespace</span>
0377     <a name="_sub5" href="#_subfunctions" class="code">function_index=find(~cellfun(@isempty,regexp(function_names,[</a><span class="string">'^'</span> monitor_namespace],<span class="string">'once'</span>)));
0378     
0379     <span class="comment">% add functions to list</span>
0380     <a name="_sub6" href="#_subfunctions" class="code">functions_to_monitor=cat(1,functions_to_monitor,function_names(function_index));</a>
0381     
0382     <span class="comment">% remove &quot;function&quot; monitor name</span>
0383     model.monitors=rmfield(model.monitors,monitor_name);
0384   <span class="keyword">end</span>
0385   
0386   <span class="comment">% eliminate duplicate function names</span>
0387   <a name="_sub7" href="#_subfunctions" class="code">functions_to_monitor=unique(functions_to_monitor);</a>
0388   
0389   <span class="comment">% add functions to monitor list</span>
0390   <span class="keyword">for</span> i=1:length(functions_to_monitor)
0391     model.monitors.(functions_to_monitor{i})=[];
0392   <span class="keyword">end</span>
0393 <span class="keyword">end</span>
0394 
0395   <span class="comment">% ----------------------------------</span>
0396   <span class="comment">% NESTED FUNCTIONS</span>
0397   <span class="comment">% ----------------------------------</span>
0398   <a name="_sub8" href="#_subfunctions" class="code">function add_keywords(src,dst,namespace)</a>
0399     <span class="comment">% NOTE: this needs to be coordinated with update_keywords() in ds.simulateModel()</span>
0400     <span class="comment">%   for parameters</span>
0401     Nsrc=[src <span class="string">'_Npop'</span>];
0402     Ndst=[dst <span class="string">'_Npop'</span>];
0403     
0404     old={<span class="string">'Npre'</span>,<span class="string">'N[1]'</span>,<span class="string">'N_pre'</span>,<span class="string">'Npost'</span>,<span class="string">'N_post'</span>,<span class="string">'N[0]'</span>,<span class="string">'Npop'</span>,<span class="string">'N_pop'</span>};
0405     new={Nsrc,Nsrc,Nsrc,Ndst,Ndst,Ndst,Ndst,Ndst};
0406     <span class="keyword">for</span> p=1:length(old)
0407       name_map(end+1,:)={old{p},new{p},namespace,<span class="string">'parameters'</span>};
0408     <span class="keyword">end</span>
0409     
0410     <span class="comment">% for state variables</span>
0411     new={};
0412     old={};
0413     src_excluded=~cellfun(@isempty,regexp(name_map(:,1),[<span class="string">'pre'</span> <span class="string">'$'</span>]));
0414     dst_excluded=~cellfun(@isempty,regexp(name_map(:,1),[<span class="string">'post'</span> <span class="string">'$'</span>]));
0415     excluded=src_excluded|dst_excluded;
0416     
0417     PopScope=[src <span class="string">'_'</span>];
0418     var_idx=strcmp(PopScope,name_map(:,3)) &amp; strcmp(<span class="string">'state_variables'</span>,name_map(:,4)) &amp; ~excluded;
0419     <span class="keyword">if</span> any(var_idx)
0420       Xsrc_old_vars=name_map(var_idx,1);
0421       Xsrc_new_vars=name_map(var_idx,2);
0422       <span class="comment">% default for IN is first Xsrc state var</span>
0423       Xsrc=Xsrc_new_vars{1};
0424       old=<a href="#_sub6" class="code" title="subfunctions_to_monitor=cat(1,functions_to_monitor,function_names(function_index));">cat</a>(2,old,{<span class="string">'IN'</span>,<span class="string">'Xpre'</span>,<span class="string">'X_pre'</span>});
0425       new=<a href="#_sub6" class="code" title="subfunctions_to_monitor=cat(1,functions_to_monitor,function_names(function_index));">cat</a>(2,new,{Xsrc,Xsrc,Xsrc});
0426     <span class="keyword">else</span>
0427       Xsrc_old_vars=[];
0428       Xsrc_new_vars=[];
0429       Xsrc=[];
0430     <span class="keyword">end</span>
0431     
0432     PopScope=[dst <span class="string">'_'</span>];
0433     var_idx=strcmp(PopScope,name_map(:,3)) &amp; strcmp(<span class="string">'state_variables'</span>,name_map(:,4)) &amp; ~excluded;
0434     <span class="keyword">if</span> any(var_idx)
0435       Xdst_old_vars=name_map(var_idx,1);
0436       Xdst_new_vars=name_map(var_idx,2);
0437       <span class="comment">% default for OUT and X is first Xdst state var</span>
0438       Xdst=Xdst_new_vars{1};
0439       old=<a href="#_sub6" class="code" title="subfunctions_to_monitor=cat(1,functions_to_monitor,function_names(function_index));">cat</a>(2,old,{<span class="string">'OUT'</span>,<span class="string">'X'</span>,<span class="string">'Xpost'</span>,<span class="string">'X_post'</span>});
0440       new=<a href="#_sub6" class="code" title="subfunctions_to_monitor=cat(1,functions_to_monitor,function_names(function_index));">cat</a>(2,new,{Xdst,Xdst,Xdst,Xdst});
0441     <span class="keyword">else</span>
0442       Xdst_old_vars=[];
0443       Xdst_new_vars=[];
0444       Xdst=[];
0445     <span class="keyword">end</span>
0446     
0447     <span class="comment">% add variants [var_pre,var_post,varpre,varpost]</span>
0448     <span class="keyword">if</span> ~isempty(Xsrc_old_vars)
0449       [Xsrc_old_vars,IA]=setdiff(Xsrc_old_vars,old);
0450       Xsrc_new_vars=Xsrc_new_vars(IA);
0451     <span class="keyword">end</span>
0452     
0453     <span class="keyword">if</span> ~isempty(Xdst_old_vars)
0454       [Xdst_old_vars,IA]=setdiff(Xdst_old_vars,old);
0455       Xdst_new_vars=Xdst_new_vars(IA);
0456     <span class="keyword">end</span>
0457     
0458     <span class="keyword">for</span> p=1:length(Xsrc_old_vars)
0459       old{end+1}=[Xsrc_old_vars{p} <span class="string">'_pre'</span>];
0460       new{end+1}=Xsrc_new_vars{p};
0461       old{end+1}=[Xsrc_old_vars{p} <span class="string">'pre'</span>];
0462       new{end+1}=Xsrc_new_vars{p};
0463     <span class="keyword">end</span>
0464     
0465     <span class="keyword">for</span> p=1:length(Xdst_old_vars)
0466       old{end+1}=[Xdst_old_vars{p} <span class="string">'_post'</span>];
0467       new{end+1}=Xdst_new_vars{p};
0468       old{end+1}=[Xdst_old_vars{p} <span class="string">'post'</span>];
0469       new{end+1}=Xdst_new_vars{p};
0470     <span class="keyword">end</span>
0471     
0472     <span class="keyword">for</span> p=1:length(old)
0473       name_map(end+1,:)={old{p},new{p},namespace,<span class="string">'state_variables'</span>};
0474     <span class="keyword">end</span>
0475   <span class="keyword">end</span>
0476 
0477 <span class="comment">%% 2.0 propagate namespaces through variable and function names</span>
0478 <span class="comment">%      i.e., to establish uniqueness of names by adding namespace/namespace prefixes)</span>
0479 model = <a href="ds.propagateNamespaces.html" class="code" title="function model = ds.propagateNamespaces(model,map)">ds.propagateNamespaces</a>(model,name_map);
0480 
0481 <span class="comment">%% 3.0 expand population equations according to mechanism linkers</span>
0482 <span class="comment">% purpose: expand population equations according to linkers</span>
0483 <span class="comment">% - link populations.equations to mechanism sub-models</span>
0484 <span class="comment">% - link mechanism functions and state variables across mechanisms in a given population</span>
0485 
0486 <span class="comment">% store indices to all expressions and conditionals that are linked (this</span>
0487 <span class="comment">% is necessary for efficiently removing linker targets from expressions after linking)</span>
0488 all_expression_inds=[];
0489 all_expression_targets={};
0490 all_conditionals_inds=[];
0491 all_conditionals_targets={};
0492 
0493 <span class="comment">% add variables to linked expression if its a function without ()</span>
0494 <span class="keyword">if</span> ~isempty(model.functions) &amp;&amp; ~isempty(model.linkers)
0495   <a name="_sub9" href="#_subfunctions" class="code">function_names=fieldnames(model.functions);</a>
0496   expressions={model.linkers.expression};
0497   [~,I,J]=intersect(function_names,expressions);
0498   <span class="keyword">for</span> i=1:length(I)
0499     e=model.functions.(function_names{J(i)}); <span class="comment">% function expression (eg,'@(x,y,z)x-(y-z)')</span>
0500     v=regexp(e,<span class="string">'@(\([\w,]+\))'</span>,<span class="string">'tokens'</span>,<span class="string">'once'</span>); <span class="comment">% function input list (eg, '(x,y,z)')</span>
0501     <span class="keyword">if</span> ~isempty(v)
0502       model.linkers(I(i)).expression=[model.linkers(I(i)).expression v{1}];
0503     <span class="keyword">end</span>
0504   <span class="keyword">end</span>
0505 <span class="keyword">end</span>
0506 
0507 <span class="comment">% loop over linkers</span>
0508 <span class="keyword">for</span> i=1:length(model.linkers)
0509   <span class="comment">% determine how to link</span>
0510   operation=model.linkers(i).operation;
0511   oldstr=model.linkers(i).target;
0512   newstr=model.linkers(i).expression;
0513   <span class="keyword">switch</span> operation <span class="comment">% see ds.classifyEquation and ds.parseModelEquations   % ('((\+=)|(-=)|(\*=)|(/=)|(=&gt;))')</span>
0514     <span class="keyword">case</span> <span class="string">'+='</span>
0515       operator=<span class="string">'+'</span>;
0516     <span class="keyword">case</span> <span class="string">'-='</span>
0517       operator=<span class="string">'-'</span>;
0518     <span class="keyword">case</span> <span class="string">'*='</span>
0519       operator=<span class="string">'.*'</span>;
0520     <span class="keyword">case</span> <span class="string">'/='</span>
0521       operator=<span class="string">'./'</span>;
0522     <span class="keyword">otherwise</span>
0523       operator=<span class="string">'+'</span>;
0524   <span class="keyword">end</span>
0525   <span class="comment">% determine what to link (ie, link across everything belonging to the linker population)</span>
0526   <span class="comment">% explicitly constrain to linker population</span>
0527   expressions_in_pop=~cellfun(@isempty,regexp(name_map(:,3),[<span class="string">'^'</span> linker_pops{i}]));
0528   
0529   <span class="keyword">if</span> ~isempty(model.conditionals)
0530     conditionals_in_pop=~cellfun(@isempty,regexp({model.conditionals.namespace},[<span class="string">'^'</span> linker_pops{i}]));
0531   <span class="keyword">end</span>
0532   
0533   <span class="keyword">if</span> ~isempty(model.linkers)
0534     linkers_in_pop=~cellfun(@isempty,regexp({model.linkers.namespace},[<span class="string">'^'</span> linker_pops{i}]));
0535   <span class="keyword">end</span>
0536   
0537   <span class="comment">% constrain to namespace</span>
0538   names_in_namespace=cellfun(@(x,y)strncmp(y,x,length(y)),name_map(:,2),name_map(:,3));
0539   
0540   <span class="comment">% get list of (functions,monitors,ODEs) belonging to the linker population</span>
0541   eqn_types={<span class="string">'ODEs'</span>,<span class="string">'monitors'</span>,<span class="string">'functions'</span>};<span class="comment">%{'monitors','ODEs'};</span>
0542   search_types={<span class="string">'state_variables'</span>,<span class="string">'monitors'</span>,<span class="string">'functions'</span>};<span class="comment">%{'monitors','state_variables'};</span>
0543   
0544   <span class="comment">% indices to expressions in the linker population with the correct search_types and namespace</span>
0545   inds=<a href="#_sub3  5" class="code" title="subfunction_monitor_index=find(~cellfun(@isempty,regexp(monitor_names,function_index=find(~cellfun(@isempty,regexp(function_names,[">find</a>(expressions_in_pop&amp;names_in_namespace&amp;ismember(name_map(:,4),search_types));
0546   
0547   <span class="comment">% eliminate duplicates (e.g., state_variables replacing OUT and X)</span>
0548   [jnk,ia,ib]=<a href="#_sub7" class="code" title="subfunctions_to_monitor=unique(functions_to_monitor);">unique</a>(name_map(inds,2),<span class="string">'stable'</span>);
0549   inds=inds(ia);
0550   all_expression_inds=[all_expression_inds inds'];
0551   all_expression_targets=<a href="#_sub6" class="code" title="subfunctions_to_monitor=cat(1,functions_to_monitor,function_names(function_index));">cat</a>(2,all_expression_targets,repmat({oldstr},[1 length(inds)]));
0552  
0553   <span class="comment">% substitute link</span>
0554   <span class="keyword">for</span> j=1:length(inds)
0555     name=name_map{inds(j),2}; <span class="comment">% name of variable as stored in model structure</span>
0556     type=name_map{inds(j),4}; <span class="comment">% search_types</span>
0557     eqn_type=eqn_types{strcmp(type,search_types)}; <span class="comment">% corresponding equation type</span>
0558     
0559     <span class="comment">% update expression with the current link</span>
0560     <span class="keyword">if</span> isfield(model.(eqn_type),name)
0561       <span class="comment">% note: name will not be a field of eqn_type for special monitors</span>
0562       <span class="comment">% (e.g., monitor functions)</span>
0563       model.(eqn_type).(name)=<a href="#_sub10" class="code" title="subfunction str=linker_strrep(str,oldstr,newstr,operator)">linker_strrep</a>(model.(eqn_type).(name),oldstr,newstr,operator);
0564     <span class="keyword">end</span>
0565   <span class="keyword">end</span>
0566   
0567   <span class="keyword">if</span> ~isempty(model.conditionals)
0568     fields={<span class="string">'condition'</span>,<span class="string">'action'</span>,<span class="string">'else'</span>};
0569     
0570     <span class="comment">% get list of conditionals belonging to the linker population</span>
0571     inds=<a href="#_sub3  5" class="code" title="subfunction_monitor_index=find(~cellfun(@isempty,regexp(monitor_names,function_index=find(~cellfun(@isempty,regexp(function_names,[">find</a>(conditionals_in_pop);
0572     all_conditionals_inds=[all_conditionals_inds inds];
0573     all_conditionals_targets=<a href="#_sub6" class="code" title="subfunctions_to_monitor=cat(1,functions_to_monitor,function_names(function_index));">cat</a>(2,all_conditionals_targets,repmat({oldstr},[1 length(inds)]));
0574     
0575     <span class="comment">% substitute link</span>
0576     <span class="keyword">for</span> j=1:length(inds)
0577       <span class="keyword">for</span> field_index=1:length(fields)
0578         field=fields{field_index};
0579         model.conditionals(inds(j)).(field)=<a href="#_sub10" class="code" title="subfunction str=linker_strrep(str,oldstr,newstr,operator)">linker_strrep</a>(model.conditionals(inds(j)).(field),oldstr,newstr,operator);
0580       <span class="keyword">end</span>
0581     <span class="keyword">end</span>
0582   <span class="keyword">end</span>
0583   
0584   <span class="keyword">if</span> ~isempty(model.linkers)
0585     inds=<a href="#_sub3  5" class="code" title="subfunction_monitor_index=find(~cellfun(@isempty,regexp(monitor_names,function_index=find(~cellfun(@isempty,regexp(function_names,[">find</a>(linkers_in_pop);
0586     <span class="keyword">for</span> j=1:length(inds)
0587       model.linkers(inds(j)).expression=<a href="#_sub10" class="code" title="subfunction str=linker_strrep(str,oldstr,newstr,operator)">linker_strrep</a>(model.linkers(inds(j)).expression,oldstr,newstr,operator);
0588     <span class="keyword">end</span>
0589   <span class="keyword">end</span>
0590 <span class="keyword">end</span>
0591 
0592 <span class="keyword">if</span> options.open_link_flag==0
0593   <span class="comment">% remove target placeholders from expressions and conditionals</span>
0594   <span class="keyword">for</span> i=1:length(all_expression_inds)
0595     oldstr=all_expression_targets{i};
0596     newstr=<span class="string">''</span>;
0597     name=name_map{all_expression_inds(i),2};
0598     type=name_map{all_expression_inds(i),4};
0599     eqn_type=eqn_types{strcmp(type,search_types)};
0600     pattern = [<span class="string">'\)\.?[-\+\*/]'</span> oldstr <span class="string">'\)'</span>]; <span class="comment">% pattern accounts for all possible newstr defined for linking</span>
0601     replace = [newstr <span class="string">'))'</span>];
0602     <span class="keyword">if</span> isfield(model.(eqn_type),name) &amp;&amp; ischar(model.(eqn_type).(name))
0603         <span class="comment">% NOTE: name will not be a field of eqn_type for special monitors</span>
0604         <span class="comment">% (e.g., monitor functions)</span>
0605       model.(eqn_type).(name)=regexprep(model.(eqn_type).(name),pattern,replace);
0606     <span class="keyword">end</span>
0607   <span class="keyword">end</span>
0608 <span class="keyword">end</span>
0609 
0610 <span class="keyword">if</span> ~isempty(model.conditionals)
0611   <span class="keyword">for</span> i=1:length(all_conditionals_inds)
0612     oldstr=all_conditionals_targets{i};
0613     newstr=<span class="string">''</span>;
0614     pattern = [<span class="string">'\)\.?[-\+\*/]'</span> oldstr <span class="string">'\)'</span>]; <span class="comment">% pattern accounts for all possible newstr defined for linking</span>
0615     replace = [newstr <span class="string">'))'</span>];
0616     <span class="keyword">for</span> field_index=1:length(fields)
0617       field=fields{field_index};
0618       <span class="keyword">if</span> model.conditionals(all_conditionals_inds(i)).(field)
0619         model.conditionals(all_conditionals_inds(i)).(field)=regexprep(model.conditionals(all_conditionals_inds(i)).(field),pattern,replace);
0620       <span class="keyword">end</span>
0621     <span class="keyword">end</span>
0622   <span class="keyword">end</span>
0623 <span class="keyword">end</span>
0624 
0625 <span class="comment">% ------------------------------------------</span>
0626 <span class="comment">% NOTE on non-ideal implementation of 3.0: model.linkers does not contain enough</span>
0627 <span class="comment">% information to determine the population to which it belongs in all cases</span>
0628 <span class="comment">% (due to namespace format differences for population vs connection mechanisms &amp; models</span>
0629 <span class="comment">% with one vs more populations). consequently, had to perform linking in this</span>
0630 <span class="comment">% function using info stored above while parsing the model; ideally, the</span>
0631 <span class="comment">% linking could occur independently of this function, informed by info in</span>
0632 <span class="comment">% model.linkers, and be packaged in its own external function LinkMechanisms().</span>
0633 <span class="comment">% ------------------------------------------</span>
0634 
0635 <span class="comment">%% 4.0 finalize</span>
0636 
0637 <span class="comment">% 4.1 sort .ODEs and .ICs wrt .state_variables</span>
0638 model.ODEs = orderfields(model.ODEs,model.state_variables);
0639 model.ICs = orderfields(model.ICs,model.state_variables);
0640 
0641 <span class="comment">% 4.2 convert to numeric parameters</span>
0642 c = struct2cell(model.parameters);
0643 
0644 <span class="comment">% get index of strings</span>
0645 idx1=<a href="#_sub3  5" class="code" title="subfunction_monitor_index=find(~cellfun(@isempty,regexp(monitor_names,function_index=find(~cellfun(@isempty,regexp(function_names,[">find</a>(cellfun(@ischar,c));
0646 
0647 <span class="comment">% which strings contain numeric values?</span>
0648 idx2=<a href="#_sub3  5" class="code" title="subfunction_monitor_index=find(~cellfun(@isempty,regexp(monitor_names,function_index=find(~cellfun(@isempty,regexp(function_names,[">find</a>(cellfun(@isempty,regexp(c(idx1),<span class="string">'[a-z_A-Z]'</span>)) | ~cellfun(@isempty,regexp(c(idx1),<span class="string">'^\s*\[*\s*\+?inf\s*\]*\s*$'</span>,<span class="string">'ignorecase'</span>)));
0649 
0650 <span class="comment">% convert those strings which contain numeric values</span>
0651 c(idx1(idx2)) = cellfun(@eval,c(idx1(idx2)),<span class="string">'uni'</span>,0);
0652 <span class="comment">%idx=cellfun(@isempty,regexp(c,'[a-z_A-Z]')) | ~cellfun(@isempty,regexp(c,'^\s*\[*\s*inf\s*\]*\s*$','ignorecase'));</span>
0653 <span class="comment">%c(idx) = cellfun(@eval,c(idx),'uni',0);</span>
0654 f = <a href="#_sub1  9" class="code" title="subfunction_names=fieldnames(model.functions);function_names=fieldnames(model.functions);">fieldnames</a>(model.parameters);
0655 model.parameters = cell2struct(c,f,1);
0656 
0657 <span class="comment">% 4.3 store original specification</span>
0658 model.specification = specification; <span class="comment">% store specification to enable modifications to be applied later</span>
0659 model.namespaces = name_map; <span class="comment">% store name_map for transparency</span>
0660 
0661 model=<a href="ds.checkModel.html" class="code" title="function model=ds.checkModel(model)">ds.checkModel</a>(model);
0662 
0663 <span class="keyword">end</span>
0664 
0665 <span class="comment">%% SUBFUNCTIONS</span>
0666 <a name="_sub10" href="#_subfunctions" class="code">function str=linker_strrep(str,oldstr,newstr,operator)</a>
0667   <span class="keyword">if</span> isempty(str)
0668     <span class="keyword">return</span>;
0669   <span class="keyword">end</span>
0670   <span class="comment">% if inserting one word (e.g., a state variable), just replace it</span>
0671   <span class="comment">% WARNING: could cause problems in future if there is an additive</span>
0672   <span class="comment">% substitution of different state variables into the same place followed</span>
0673   <span class="comment">% by non-additive operations (e.g., @cai+=cai1 and @cai+=cai2 into</span>
0674   <span class="comment">% v'=f(v)*cai where cai1 &amp; cai2 are defined in mechanisms for the same v;</span>
0675   <span class="comment">% workaround: insert into v'=f(v)*(cai)).</span>
0676   
0677   <span class="comment">% check if anything besides a single variable:</span>
0678   <span class="keyword">if</span> isempty(regexp(newstr,<span class="string">'[^a-z_A-Z\d]+'</span>,<span class="string">'once'</span>))
0679     str=ds.strrep(str,oldstr,newstr);
0680   <span class="keyword">else</span>
0681     <span class="comment">% otherwise do substitution with operator and parenthesis</span>
0682     pat=[<span class="string">'([^\w]+)'</span> oldstr <span class="string">'([^\w]+)'</span>]; <span class="comment">% in the middle</span>
0683     rep=[<span class="string">'$1(('</span> newstr <span class="string">')'</span> operator oldstr <span class="string">')$2'</span>];
0684     str=regexprep(str,pat,rep);
0685     pat=[<span class="string">'([^\w]+)'</span> oldstr <span class="string">'$'</span>];        <span class="comment">% at the end</span>
0686     rep=[<span class="string">'$1(('</span> newstr <span class="string">')'</span> operator oldstr <span class="string">')'</span>];
0687     str=regexprep(str,pat,rep);
0688     pat=[<span class="string">'^'</span> oldstr <span class="string">'([^\w]+)'</span>];        <span class="comment">% at the beginning</span>
0689     rep=[<span class="string">'(('</span> newstr <span class="string">')'</span> operator oldstr <span class="string">')$1'</span>];
0690     str=regexprep(str,pat,rep);
0691     pat=[<span class="string">'^'</span> oldstr <span class="string">'$'</span>];               <span class="comment">% all there is</span>
0692     rep=[<span class="string">'(('</span> newstr <span class="string">')'</span> operator oldstr <span class="string">')'</span>];
0693     str=regexprep(str,pat,rep);
0694   <span class="keyword">end</span>
0695 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Fri 07-Apr-2017 20:01:20 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>