<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of ds.xPlt.xPlt2ds</title>
  <meta name="keywords" content="ds.xPlt.xPlt2ds">
  <meta name="description" content="% data=ds.xPlt.xPlt2ds(obj,varargin)">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- menu.html functions -->
<h1>ds.xPlt.xPlt2ds
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>% data=ds.xPlt.xPlt2ds(obj,varargin)</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function data=ds.xPlt.xPlt2ds(obj) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment">% data=ds.xPlt.xPlt2ds(obj,varargin)
 Dependencies:
   Requires the MDD class, which should be part of DynaSim. If not,
   get it here https://github.com/davestanley/MDD
 Author: David Stanley, Boston University, stanleyd@bu.edu</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="ds.checkData.html" class="code" title="function data=ds.checkData(data)">ds.checkData</a>	CHECKDATA - Standardize data structure and auto-populate missing fields</li><li><a href="../functions/supporting_ds.ds2xPlt/ds.xPlt.get_populations_from_meta.html" class="code" title="function poplabels = ds.xPlt.get_populations_from_meta(xp)">ds.xPlt.get_populations_from_meta</a>	</li><li><a href="../functions/supporting_ds.ds2xPlt/ds.xPlt.get_variables_from_meta.html" class="code" title="function varlabels = ds.xPlt.get_variables_from_meta(xp)">ds.xPlt.get_variables_from_meta</a>	</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="ds.merge.html" class="code" title="function data_merged = ds.mergeData(data1,data2)">ds.merge</a>	Merge two Dynasim structures created from different simulations</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="#_sub1" class="code">function varied_names = only_varieds(all_names)</a></li><li><a href="#_sub2" class="code">function data = add_pop_sizes(data,obj,num_pops,pop_names)</a></li><li><a href="#_sub3" class="code">function labels = get_axis_labels(obj,ax_vals)</a></li><li><a href="#_sub4" class="code">function out = guess_variable_name(obj)</a></li><li><a href="#_sub5" class="code">function out = guess_population_name(obj)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function data=ds.xPlt.xPlt2ds(obj)</a>
0002 <span class="comment">%% data=ds.xPlt.xPlt2ds(obj,varargin)</span>
0003 <span class="comment">% Dependencies:</span>
0004 <span class="comment">%   Requires the MDD class, which should be part of DynaSim. If not,</span>
0005 <span class="comment">%   get it here https://github.com/davestanley/MDD</span>
0006 <span class="comment">% Author: David Stanley, Boston University, stanleyd@bu.edu</span>
0007 
0008 <span class="comment">% This combines the 2D &quot;vary&quot; sweep into a single dimension. It also</span>
0009 <span class="comment">% combines all populations and variables into a single 1D list. Thus, Axis</span>
0010 <span class="comment">% 1 is equivalent to Jason's structure array - data(1:9). Axis 4 is</span>
0011 <span class="comment">% equivalent to the structure fields in Jason's DynaSim structure.</span>
0012 <span class="comment">%</span>
0013 <span class="comment">% % % Testing code</span>
0014 <span class="comment">% load sample_data_dynasim.mat</span>
0015 <span class="comment">% data1=data;</span>
0016 <span class="comment">% data2 = data(1);</span>
0017 <span class="comment">% d1 = ds.xPlt.xPlt2ds(ds.ds2xPlt(data1));</span>
0018 <span class="comment">% d2 = ds.xPlt.xPlt2ds(ds.ds2xPlt(data2));</span>
0019 <span class="comment">% d2b = ds.xPlt.xPlt2ds(squeeze(ds.ds2xPlt(data2)));</span>
0020 <span class="comment">% % Make sure 1 is identical</span>
0021 <span class="comment">% close all;</span>
0022 <span class="comment">% ds.plotData(data1); ds.plotData(d1);</span>
0023 <span class="comment">% % Make sure 2 is identical</span>
0024 <span class="comment">% ds.plotData(data2); ds.plotData(d2);</span>
0025 <span class="comment">% ds.plotData(data2); ds.plotData(d2b);</span>
0026 
0027 <span class="comment">% If population axis doesn't exist, create it</span>
0028 
0029 
0030 <span class="comment">% Add dummy axis for variables if needed</span>
0031 <span class="keyword">if</span> isempty(obj.findaxis(<span class="string">'variables'</span>))
0032     Na = length(obj.axis);
0033     obj.axis(Na+1).name = <span class="string">'variables'</span>;
0034     obj.axis(Na+1).values = {<a href="#_sub4" class="code" title="subfunction out = guess_variable_name(obj)">guess_variable_name</a>(obj)};
0035 <span class="keyword">end</span>
0036 
0037 <span class="comment">% Add dummy axis for populations if needed</span>
0038 <span class="keyword">if</span> isempty(obj.findaxis(<span class="string">'populations'</span>))
0039     Na = length(obj.axis);
0040     obj.axis(Na+1).name = <span class="string">'populations'</span>;
0041     obj.axis(Na+1).values = {<a href="#_sub5" class="code" title="subfunction out = guess_population_name(obj)">guess_population_name</a>(obj)};
0042 <span class="keyword">end</span>
0043 
0044 <span class="comment">% Get rid of any empty Dims created by above operations</span>
0045 obj = obj.squeezeRegexp(<span class="string">'Dim'</span>);
0046 
0047 <span class="comment">% Find population and variable axes</span>
0048 pop_axis = obj.findaxis(<span class="string">'populations'</span>);
0049 var_axis = obj.findaxis(<span class="string">'variables'</span>);
0050 
0051 <span class="comment">% Find varied axes</span>
0052 varied_inds = true(1,ndims(obj)); varied_inds(pop_axis) = false; varied_inds(var_axis) = false;
0053 varied_axis = find(varied_inds);
0054 has_varied = ~isempty(varied_axis);
0055 
0056 <span class="comment">% Bring pop and var to front</span>
0057 obj = obj.permute([pop_axis,var_axis, varied_axis(:)']);
0058 
0059 <span class="comment">% Find population sizes for each population (will be used MUCH later)</span>
0060 num_pops = size(obj,1);
0061 pop_names = obj.exportAxisVals; pop_names = pop_names{1};
0062 
0063 <span class="comment">% Should be populations x variables x varied</span>
0064 
0065 <span class="comment">% Merge populations and variables together</span>
0066 obj = obj.mergeDims(1:2);
0067 
0068 <span class="comment">% Merge all other varied variables</span>
0069 <span class="keyword">if</span> has_varied
0070     obj = obj.mergeDims(3:ndims(obj));
0071 <span class="keyword">end</span>
0072 
0073 <span class="comment">% Should now be populations_variables x Dim 1 x varied1_varied2_.... x Dim2</span>
0074 
0075 <span class="comment">% Get rid of any leftover axes created by mergeDims</span>
0076 obj = obj.squeezeRegexp(<span class="string">'Dim'</span>);
0077 
0078 <span class="comment">% Should now be populations_variables x varied1_varied2_....</span>
0079 
0080 <span class="comment">% Build DynaSim data structure</span>
0081 data = struct;
0082 ax_vals = obj.exportAxisVals;
0083 ax_names = obj.exportAxisNames;
0084 <span class="keyword">if</span> has_varied
0085     varied = obj.axis(2).astruct.premerged_names;
0086     varied_vals = obj.axis(2).astruct.premerged_values;
0087 <span class="keyword">end</span>
0088 
0089 <span class="keyword">for</span> j = 1:size(obj,2)                               <span class="comment">% Loop through varieds</span>
0090     
0091     <span class="comment">% Add actual data</span>
0092     <span class="keyword">for</span> i = 1:size(obj,1)                           <span class="comment">% Loop through populations</span>
0093         data(j).(ax_vals{1}{i}) = obj.data{i,j};
0094     <span class="keyword">end</span>
0095     
0096     <span class="comment">% If there are any varied parameters....</span>
0097     <span class="keyword">if</span> has_varied
0098         <span class="comment">% Add list of varied variables</span>
0099         data(j).varied = varied;
0100 
0101         <span class="comment">% Add values of varied variables</span>
0102         <span class="keyword">for</span> i = 1:length(varied)
0103             data(j).(varied{i}) = varied_vals{i}(j);
0104         <span class="keyword">end</span>
0105     <span class="keyword">end</span>
0106     
0107     <span class="comment">% Add other DynaSim info if present</span>
0108     obj_curr = obj.meta.dynasim;
0109     <span class="comment">%fc = 'labels'; if isfield(obj_curr,fc); data(j).(fc) = obj_curr.(fc); end</span>
0110     fc = <span class="string">'model'</span>; <span class="keyword">if</span> isfield(obj_curr,fc); data(j).(fc) = obj_curr.(fc); <span class="keyword">end</span>
0111     fc = <span class="string">'simulator_options'</span>; <span class="keyword">if</span> isfield(obj_curr,fc); data(j).(fc) = obj_curr.(fc); <span class="keyword">end</span>
0112     fc = <span class="string">'time'</span>; <span class="keyword">if</span> isfield(obj_curr,fc); data(j).(fc) = obj_curr.(fc); <span class="keyword">end</span>
0113 <span class="keyword">end</span>
0114 
0115 <span class="comment">% Update data.labels</span>
0116 labels = <a href="#_sub3" class="code" title="subfunction labels = get_axis_labels(obj,ax_vals)">get_axis_labels</a>(obj,ax_vals);
0117 <span class="keyword">for</span> j = 1:length(data)
0118     data(j).labels = labels;
0119 <span class="keyword">end</span>
0120 
0121 <span class="comment">% Lastly, update population sizes (data(i).model.specification.populations(j).size)</span>
0122 data = <a href="#_sub2" class="code" title="subfunction data = add_pop_sizes(data,obj,num_pops,pop_names)">add_pop_sizes</a>(data,obj,num_pops,pop_names);
0123 
0124 data = <a href="ds.checkData.html" class="code" title="function data=ds.checkData(data)">ds.checkData</a>(data);
0125 
0126 
0127 <span class="keyword">end</span>
0128 
0129 
0130 <a name="_sub1" href="#_subfunctions" class="code">function varied_names = only_varieds(all_names)</a>
0131     inds = true(1,length(all_names));
0132     inds(strcmp(all_names,<span class="string">'populations'</span>)) = false; 
0133     inds(strcmp(all_names,<span class="string">'variables'</span>)) = false;
0134     varied_names = all_names(inds);
0135 <span class="keyword">end</span>
0136 
0137 <a name="_sub2" href="#_subfunctions" class="code">function data = add_pop_sizes(data,obj,num_pops,pop_names)</a>
0138     <span class="comment">% num_pops = size(obj,1);</span>
0139     <span class="keyword">for</span> i = 1:length(data)
0140         <span class="keyword">for</span> j = 1:num_pops
0141             obj_temp = obj([<span class="string">'^'</span> pop_names{j}],i);   <span class="comment">% ^ is regexp for begins with</span>
0142 
0143             <span class="comment">% Get list of sizes of all variables in this population</span>
0144             pop_sz = cellfun(@(x) size(x,2),obj_temp.data);
0145 
0146             <span class="comment">% Find state variable in this population - this one will tell</span>
0147             <span class="comment">% us the size of the population</span>
0148             var_names = obj_temp.axis(<span class="string">'populations_variables'</span>).values;
0149             num_vars = length(var_names);
0150             ind = regexp(lower(var_names),<span class="string">'_v$||_vm$||_x$||_xm$||_y$||_ym$'</span>);        <span class="comment">% Search for all variables to get ones ending in the name of a state variable</span>
0151             ind = ~cellfun(@isempty,ind);
0152             <span class="keyword">if</span> all(ind == 0)    <span class="comment">% If estimation process failed...</span>
0153                 <span class="comment">% warning('State variable name was not one of the following: {V, Vm, X, Xm, Y, Ym}. Defaulting to back up algorithm for guessing.');</span>
0154 
0155                 <span class="comment">% Instead, try to find any populations that aren't</span>
0156                 <span class="comment">% following the synapse naming convention:</span>
0157                 <span class="comment">% (PopPost_PopPre_Variable)</span>
0158                 ind = true(1,num_vars);
0159                 <span class="keyword">for</span> k = 1:num_pops
0160                     <span class="keyword">if</span> k == j; <span class="keyword">continue</span>; <span class="keyword">end</span>
0161                     searchstr = [<span class="string">'^'</span> pop_names{j} <span class="string">'_'</span> pop_names{k} <span class="string">'_'</span>];
0162                     ind3 = regexp(var_names,searchstr);
0163                     ind3 = ~cellfun(@isempty,ind3);
0164                     ind(ind3) = false;
0165                 <span class="keyword">end</span>
0166                 ind = ind &amp; pop_sz(:)' ~= 0;
0167 
0168             <span class="keyword">end</span>
0169             <span class="comment">% Select the variable(s) most likely to represent this</span>
0170             <span class="comment">% population</span>
0171             pop_sz2 = pop_sz(ind);  <span class="comment">% Get rid of empties if any</span>
0172 
0173 
0174     <span class="comment">%         % % Make sure that all variables have the same population size</span>
0175     <span class="comment">%             % Disabling this error, since some variables with the same</span>
0176     <span class="comment">%             % population prefix CAN have different sizes - namely synaptic</span>
0177     <span class="comment">%             % state vars will have same size as presynaptic population</span>
0178     <span class="comment">%         if any(pop_sz2 ~= mode(pop_sz2)); error('Variables in population %s have differing population sizes',pop_names{j}); end</span>
0179 
0180             <span class="comment">% Assign population size to model info</span>
0181             data(i).model.specification.populations(j).size = mode(pop_sz2);
0182         <span class="keyword">end</span>   
0183     <span class="keyword">end</span>
0184 <span class="keyword">end</span>
0185 
0186 
0187 <a name="_sub3" href="#_subfunctions" class="code">function labels = get_axis_labels(obj,ax_vals)</a>
0188     <span class="comment">% This approach preserves the ordering in the original list of labels</span>
0189     <span class="comment">% (labels_orig). This is important because ds.plotData uses the specific</span>
0190     <span class="comment">% ordering in order to tell what the core state variables are.</span>
0191     <span class="comment">% The current labels are stored in labels_curr. The algorithm is to</span>
0192     <span class="comment">% 1. Start with labels_orig and figure out which are already</span>
0193     <span class="comment">%    present in labels_curr. Keep these and throw the rest out.</span>
0194     <span class="comment">% 2. Any that are not in labels_orig that are in labels_curr will be</span>
0195     <span class="comment">%    tacked on at the end</span>
0196 
0197     labels_orig = obj.meta.dynasim.labels;
0198     labels_curr = {ax_vals{1}{:}, <span class="string">'time'</span>};
0199     ind_keep = false(1,length(labels_orig));
0200     ind_remove = true(1,length(labels_curr));
0201     <span class="keyword">for</span> i = 1:length(labels_curr)
0202         <span class="comment">% If current label found in originals, flag it to keep</span>
0203         ind_temp = strcmp(labels_orig,labels_curr{i});
0204         ind_keep = ind_keep | ind_temp;
0205 
0206         <span class="comment">% If it was found, then remove it from the current list</span>
0207         <span class="keyword">if</span> any(ind_temp)
0208             ind_temp = strcmp(labels_curr,labels_curr{i});
0209             ind_remove(ind_temp) = 0;   <span class="comment">% remove from current label</span>
0210         <span class="keyword">end</span>
0211     <span class="keyword">end</span>
0212 
0213     labels_orig = labels_orig(ind_keep);
0214     labels_curr = labels_curr(ind_remove);
0215     labels = {labels_orig{:} labels_curr{:}};
0216     
0217     labels = labels(:)';
0218 <span class="keyword">end</span>
0219 
0220 
0221 <a name="_sub4" href="#_subfunctions" class="code">function out = guess_variable_name(obj)</a>
0222     <span class="comment">% The first population's state variable should always be the 1st one</span>
0223     <span class="comment">% according to DynaSim conventions</span>
0224 
0225     out = <a href="../functions/supporting_ds.ds2xPlt/ds.xPlt.get_variables_from_meta.html" class="code" title="function varlabels = ds.xPlt.get_variables_from_meta(xp)">ds.xPlt.get_variables_from_meta</a>(obj);
0226     out = out{1};
0227     <span class="keyword">if</span> isempty(out)
0228         out = <span class="string">'v'</span>;
0229     <span class="keyword">end</span>
0230 
0231 <span class="keyword">end</span>
0232 
0233 
0234 
0235 <a name="_sub5" href="#_subfunctions" class="code">function out = guess_population_name(obj)</a>
0236     <span class="comment">% The first population should always be the 1st label</span>
0237     <span class="comment">% according to DynaSim conventions</span>
0238     
0239     out = <a href="../functions/supporting_ds.ds2xPlt/ds.xPlt.get_populations_from_meta.html" class="code" title="function poplabels = ds.xPlt.get_populations_from_meta(xp)">ds.xPlt.get_populations_from_meta</a>(obj);
0240     out = out{1};
0241 
0242     <span class="keyword">if</span> isempty(out)
0243         out = <span class="string">'E'</span>;
0244     <span class="keyword">end</span>
0245     
0246 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Fri 07-Apr-2017 20:01:20 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>