<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of ds.studyinfoIO</title>
  <meta name="keywords" content="ds.studyinfoIO">
  <meta name="description" content="STUDYINFOIO - use lock files to manage concurrent access to a shared studyinfo">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- menu.html functions -->
<h1>ds.studyinfoIO
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>STUDYINFOIO - use lock files to manage concurrent access to a shared studyinfo</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function studyinfo=ds.studyinfoIO(studyinfo,study_file,id,verbose_flag) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment">STUDYINFOIO - use lock files to manage concurrent access to a shared studyinfo 

 This is an internal helper function called by ds.checkStudyinfo, ds.setupStudy,
 TrackStudy, and ds.createBatch to prevent busy-file conflicts. file. i.e.,
 serialize read/writes for parallel processes in study batch.

 Usage:
   loading: studyinfo=ds.studyinfoIO([],study_file,[id,verbose_flag])
   saving:  ds.studyinfoIO(studyinfo,[study_file,id,verbose_flag]);

 Inputs:
   - studyinfo: (empty [] for loading) or (DynaSim studyinfo structure to save)
   - study_file: name of file to load or save
   - id: process identifier for lock file name [optional]</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="displayError.html" class="code" title="function displayError(err)">displayError</a>	DISPLAYERROR - Wrapper to print MATLAB error</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="ds.checkStudyinfo.html" class="code" title="function studyinfo=ds.checkStudyinfo(studyinfo,varargin)">ds.checkStudyinfo</a>	CHECKSTUDYINFO - Standardize studyinfo structure and auto-populate missing fields</li><li><a href="ds.createBatch.html" class="code" title="function studyinfo = ds.createBatch(base_model,modifications_set,varargin)">ds.createBatch</a>	CREATEBATCH - create and submit jobs to run sets of simulations or analyses.</li><li><a href="ds.setupStudy.html" class="code" title="function [studyinfo,options]=ds.setupStudy(base_model,varargin)">ds.setupStudy</a>	SETUPSTUDY - Initialize DynaSim studyinfo structure, prepare list of output file names, and create output directories</li><li><a href="ds.updateStudy.html" class="code" title="function studyinfo=ds.updateStudy(study_dir,varargin)">ds.updateStudy</a>	UPDATESTUDY - helper function to keep track of study metadata when anything is saved</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="#_sub1" class="code">function id=NextStudyinfoID(study_dir,OS)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function studyinfo=ds.studyinfoIO(studyinfo,study_file,id,verbose_flag)</a>
0002 <span class="comment">%STUDYINFOIO - use lock files to manage concurrent access to a shared studyinfo</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% This is an internal helper function called by ds.checkStudyinfo, ds.setupStudy,</span>
0005 <span class="comment">% TrackStudy, and ds.createBatch to prevent busy-file conflicts. file. i.e.,</span>
0006 <span class="comment">% serialize read/writes for parallel processes in study batch.</span>
0007 <span class="comment">%</span>
0008 <span class="comment">% Usage:</span>
0009 <span class="comment">%   loading: studyinfo=ds.studyinfoIO([],study_file,[id,verbose_flag])</span>
0010 <span class="comment">%   saving:  ds.studyinfoIO(studyinfo,[study_file,id,verbose_flag]);</span>
0011 <span class="comment">%</span>
0012 <span class="comment">% Inputs:</span>
0013 <span class="comment">%   - studyinfo: (empty [] for loading) or (DynaSim studyinfo structure to save)</span>
0014 <span class="comment">%   - study_file: name of file to load or save</span>
0015 <span class="comment">%   - id: process identifier for lock file name [optional]</span>
0016 
0017 <span class="comment">% check inputs</span>
0018 <span class="keyword">if</span> nargin&lt;4, verbose_flag=0; <span class="keyword">end</span>
0019 <span class="keyword">if</span> nargin&lt;3, id=[]; <span class="keyword">end</span>
0020 <span class="keyword">if</span> nargin&lt;2 || isempty(study_file)
0021   study_file=<span class="string">'studyinfo.mat'</span>; 
0022 <span class="keyword">elseif</span> isdir(study_file)
0023   study_file=fullfile(study_file,<span class="string">'studyinfo.mat'</span>);
0024 <span class="keyword">end</span>
0025 study_dir=fileparts(study_file);
0026 <span class="keyword">if</span> nargin&lt;1, studyinfo=[]; <span class="keyword">end</span>
0027 
0028 <span class="comment">% determine operating system</span>
0029 [~,OS]=system(<span class="string">'uname'</span>);
0030 OS=lower(strtrim(OS)); <span class="comment">% operating system (uname: 'Linux', 'Darwin' (Mac), error (Windows))</span>
0031 <span class="keyword">if</span> length(OS)&gt;7
0032   <span class="comment">% remove dump (occurs randomly for some reason, with low frequency)</span>
0033   OS=strtrim(OS(end-6:end));
0034 <span class="keyword">end</span>
0035 
0036 <span class="comment">%% prepare action-specific parameters for accessing studyinfo</span>
0037 
0038 <span class="keyword">if</span> isempty(id)
0039   <span class="comment">% extract process IDs from names of all current lock files</span>
0040   curr_ids=[];
0041   <span class="keyword">switch</span> OS
0042     <span class="keyword">case</span> {<span class="string">'linux'</span>,<span class="string">'darwin'</span>} <span class="comment">% Linux or Mac</span>
0043       <span class="comment">% lock_file format: .lock_&lt;timestamp&gt;_&lt;id&gt;</span>
0044       [status,result]=system([<span class="string">'ls '</span> study_dir <span class="string">'/.lock_*'</span>]);
0045       <span class="keyword">if</span> status==0
0046         ids=regexp(result,<span class="string">'.lock_\d+_(\d+)'</span>,<span class="string">'tokens'</span>);
0047         <span class="keyword">if</span> ~isempty(ids), curr_ids=cell2num([ids{:}]); <span class="keyword">end</span>
0048       <span class="keyword">end</span>
0049     <span class="keyword">otherwise</span> <span class="comment">% Windows</span>
0050       <span class="comment">% lock_file format: lock_&lt;timestamp&gt;_&lt;id&gt;</span>
0051       D=dir(study_dir);
0052       status=~any(find(~cellfun(@isempty,regexp({D.name},<span class="string">'^lock_'</span>))));
0053       <span class="keyword">if</span> status==0
0054         ids=regexp({D.name},<span class="string">'lock_\d+_(\d+)'</span>,<span class="string">'tokens'</span>,<span class="string">'once'</span>); 
0055         <span class="keyword">if</span> ~isempty(ids), curr_ids=cell2num([ids{:}]); <span class="keyword">end</span>
0056       <span class="keyword">end</span>
0057   <span class="keyword">end</span>
0058 <span class="keyword">end</span>
0059 
0060 MIN_LOAD_ID=1e7; <span class="comment">% 10M</span>
0061   <span class="comment">% should be set to a number larger than the max number of sims or analyses expected in a batch</span>
0062   <span class="comment">% note: this gives priority to loading over saving</span>
0063   <span class="comment">% (since NextStudyinfoID = max existing lock id with min timestamp)</span>
0064 
0065 <span class="comment">% determine proper settings based on inputs (whether studyinfo struct was</span>
0066 <span class="comment">% provided to be saved or not)</span>
0067 <span class="keyword">if</span> isempty(studyinfo)
0068   <span class="comment">% &quot;Load Study&quot; settings</span>
0069   action=<span class="string">'load'</span>;
0070   <span class="keyword">if</span> isempty(id)
0071     <span class="comment">% get id from max id of existing locks with id&gt;=MIN_LOAD_ID else id=MIN_LOAD_ID</span>
0072     <span class="keyword">if</span> ~isempty(curr_ids) &amp;&amp; any(curr_ids&gt;=MIN_LOAD_ID)
0073       id=max(curr_ids)+1;
0074     <span class="keyword">else</span>
0075       id=MIN_LOAD_ID; <span class="comment">% value greater than the max # of batch processes (i.e., greater than the max process ID)</span>
0076     <span class="keyword">end</span>
0077   <span class="keyword">end</span>
0078   <span class="keyword">if</span> ~exist(study_file,<span class="string">'file'</span>)
0079     error(<span class="string">'studyinfo.mat file not found: %s'</span>,study_file);
0080   <span class="keyword">end</span>
0081 <span class="keyword">else</span>
0082   <span class="comment">% &quot;Save Study&quot; settings</span>
0083   action=<span class="string">'save'</span>;
0084   <span class="keyword">if</span> isempty(id)
0085     <span class="comment">% get id from max id of existing locks else 0</span>
0086     <span class="keyword">if</span> ~isempty(curr_ids) &amp;&amp; any(curr_ids&lt;MIN_LOAD_ID) &amp;&amp; ismember(0,curr_ids)
0087       id=max(curr_ids)+1;
0088     <span class="keyword">else</span>
0089       id=0; <span class="comment">% note: batch process IDs start at id=1</span>
0090     <span class="keyword">end</span>
0091   <span class="keyword">end</span>
0092 <span class="keyword">end</span>
0093 
0094 <span class="comment">%% create lock file for this process (id): lock_&lt;timestamp&gt;_&lt;id&gt;</span>
0095 timestamp=datestr(now,<span class="string">'yyyymmddHHMMSSFFF'</span>); <span class="comment">% millisecond precision</span>
0096 <span class="comment">% --------------------------------------------</span>
0097 <span class="keyword">switch</span> OS
0098   <span class="keyword">case</span> {<span class="string">'linux'</span>,<span class="string">'darwin'</span>} <span class="comment">% Linux or Mac</span>
0099     lock_file=fullfile(study_dir,sprintf(<span class="string">'.lock_%s_%i'</span>,timestamp,id));
0100     [s,r]=system([<span class="string">'touch '</span> lock_file]);
0101     <span class="keyword">if</span> s, error(r); <span class="keyword">end</span>
0102     common_lock_file=fullfile(study_dir,<span class="string">'.locked'</span>);
0103   <span class="keyword">otherwise</span> <span class="comment">% Windows</span>
0104     lock_file=fullfile(study_dir,sprintf(<span class="string">'lock_%s_%i'</span>,timestamp,id));
0105     fid=fopen(lock_file,<span class="string">'w'</span>);
0106     fclose(fid);
0107     common_lock_file=fullfile(study_dir,<span class="string">'locked'</span>);
0108 <span class="keyword">end</span>
0109 <span class="comment">% --------------------------------------------</span>
0110 <span class="keyword">if</span> verbose_flag
0111   fprintf(<span class="string">'created temporary lock file for this process: %s\n'</span>,lock_file);
0112 <span class="keyword">end</span>
0113 
0114 <span class="comment">% pause to allow lock files of simultaneous processes to appear</span>
0115 <span class="comment">% pause(.01); % wait 10ms</span>
0116 
0117 <span class="keyword">try</span>
0118   
0119 <span class="comment">%% perform action (load or save) for this process when it's ID is the Next ID</span>
0120 timeout=30; <span class="comment">% seconds, total time to wait before failing to access studyinfo</span>
0121 delay=0.001; <span class="comment">% seconds, time to pause between attempts to access studyinfo</span>
0122 max_num_timeouts=50; <span class="comment">% # timeouts before giving up</span>
0123   <span class="comment">% note: each failed attempt may remove &lt;=1 stale lock file blocking this process</span>
0124 cnt=1; <span class="comment">% attempt counter</span>
0125 done=0; <span class="comment">% {0,1} whether the action has completed successfully</span>
0126 <span class="keyword">while</span> ~done
0127   <span class="comment">% try accessing studyinfo file and remove stale lock file if necessary after timeout</span>
0128   <span class="keyword">for</span> idx=1:(timeout/delay)
0129     next_id=<a href="#_sub1" class="code" title="subfunction id=NextStudyinfoID(study_dir,OS)">NextStudyinfoID</a>(study_dir,OS);
0130     <span class="comment">% check if it's time for this process to perform its action</span>
0131     <span class="keyword">if</span> (id==next_id) &amp;&amp; ~exist(common_lock_file,<span class="string">'file'</span>)
0132       <span class="comment">% create common lock</span>
0133       <span class="keyword">switch</span> OS
0134         <span class="keyword">case</span> {<span class="string">'linux'</span>,<span class="string">'darwin'</span>} <span class="comment">% Linux or Mac</span>
0135           [s,r]=system([<span class="string">'touch '</span> common_lock_file]);
0136           <span class="keyword">if</span> s, error(r); <span class="keyword">end</span>
0137         <span class="keyword">otherwise</span>
0138           fid=fopen(common_lock_file,<span class="string">'w'</span>);
0139           fclose(fid);          
0140       <span class="keyword">end</span>      
0141       <span class="keyword">try</span>
0142         <span class="keyword">switch</span> action
0143           <span class="keyword">case</span> <span class="string">'load'</span>
0144             <span class="comment">% load study_file</span>
0145             <span class="keyword">if</span> verbose_flag
0146               fprintf(<span class="string">'loading study file: %s\n'</span>,study_file);
0147             <span class="keyword">end</span>
0148             studyinfo=getfield(load(study_file,<span class="string">'studyinfo'</span>),<span class="string">'studyinfo'</span>);
0149           <span class="keyword">case</span> <span class="string">'save'</span>
0150             <span class="keyword">if</span> isfield(studyinfo,<span class="string">'sim_id'</span>)
0151               <span class="comment">% input is actually an updated simulation metadata substructure</span>
0152               simulations=studyinfo;
0153               <span class="comment">% load studyinfo from disk</span>
0154               studyinfo=getfield(load(study_file,<span class="string">'studyinfo'</span>),<span class="string">'studyinfo'</span>);
0155               <span class="comment">% update simulation metadata</span>
0156               <span class="keyword">for</span> sim=1:length(simulations)
0157                 ix=[studyinfo.simulations.sim_id]==simulations(sim).sim_id;
0158                 studyinfo.simulations(ix)=simulations(sim);
0159               <span class="keyword">end</span>
0160               <span class="keyword">if</span> verbose_flag
0161                 fprintf(<span class="string">'updating simulation metadata in study file: %s\n'</span>,study_file);
0162               <span class="keyword">end</span>              
0163             <span class="keyword">else</span>
0164               <span class="keyword">if</span> verbose_flag
0165                 fprintf(<span class="string">'saving study file: %s\n'</span>,study_file);
0166               <span class="keyword">end</span>              
0167             <span class="keyword">end</span>
0168             <span class="comment">% save study_file</span>
0169             save(study_file,<span class="string">'studyinfo'</span>);
0170             <span class="comment">%save(study_file,'studyinfo','-v7.3');</span>
0171         <span class="keyword">end</span>
0172         done=1; <span class="keyword">break</span>;
0173       <span class="keyword">catch</span>
0174         <span class="keyword">if</span> verbose_flag
0175           fprintf(<span class="string">'failed to %s study file: %s\n'</span>,action,study_file);
0176         <span class="keyword">end</span>
0177         pause(delay); <span class="comment">% wait</span>
0178       <span class="keyword">end</span>
0179     <span class="keyword">else</span>
0180       pause(delay); <span class="comment">% wait</span>
0181     <span class="keyword">end</span>
0182     <span class="comment">% check if next_id is unchanged (i.e., the same lock file continues</span>
0183     <span class="comment">% to block this process)</span>
0184     <span class="keyword">if</span> idx==1
0185       is_unchanged=1;
0186     <span class="keyword">else</span>
0187       is_unchanged = is_unchanged &amp;&amp; (next_id==last_next_id);
0188     <span class="keyword">end</span>
0189     last_next_id=next_id;
0190   <span class="keyword">end</span>
0191   <span class="comment">% if timed out and next_id has stayed the same: remove next_id lock</span>
0192   <span class="keyword">if</span> idx==(timeout/delay) &amp;&amp; is_unchanged
0193     <span class="comment">% remove lock on next_id (that process may have failed before removing</span>
0194     <span class="comment">% its lock file)</span>
0195     D=dir(study_dir); <span class="comment">% contents of study_dir directory</span>
0196     pat=sprintf(<span class="string">'^.?lock_\\d+_%i$'</span>,last_next_id);
0197     ind=find(~cellfun(@isempty,regexp({D.name},pat)));
0198     <span class="keyword">if</span> ~isempty(ind)    
0199       next_lock_file=D(ind).name; <span class="comment">% file with next_id (^.?lock_*_&lt;next_id&gt;$)</span>
0200       <span class="keyword">if</span> verbose_flag
0201         fprintf(<span class="string">'deleting stale temporary lock file: %s\n'</span>,next_lock_file);
0202       <span class="keyword">end</span>
0203       delete(next_lock_file);
0204       delete(common_lock_file);
0205     <span class="keyword">end</span>
0206   <span class="keyword">end</span>
0207   <span class="keyword">if</span> ~done
0208     <span class="keyword">if</span> verbose_flag
0209       fprintf(<span class="string">'TIMEOUT #%g while waiting to %s study file for process %g (next_id=%g).\n'</span>,cnt,action,id,next_id);
0210     <span class="keyword">end</span>    
0211     cnt=cnt+1;
0212   <span class="keyword">end</span>
0213   <span class="comment">% check if max attempts has been exceeded</span>
0214   <span class="keyword">if</span> cnt&gt;max_num_timeouts
0215     <span class="comment">% delete this process's lock file and give up on action</span>
0216     <span class="keyword">if</span> verbose_flag
0217       fprintf(<span class="string">'deleting temporary lock file for this process: %s\n'</span>,lock_file);
0218     <span class="keyword">end</span>
0219     delete(lock_file);
0220     delete(common_lock_file);
0221     error(<span class="string">'failed to access studyinfo file after %g timeouts.'</span>,max_num_timeouts);
0222   <span class="keyword">end</span>
0223 <span class="keyword">end</span>
0224 <span class="comment">% remove temporary lock for this process</span>
0225 <span class="keyword">if</span> verbose_flag
0226   fprintf(<span class="string">'deleting temporary lock file for this process: %s\n'</span>,lock_file);
0227 <span class="keyword">end</span>
0228 delete(lock_file);
0229 delete(common_lock_file);
0230 
0231 <span class="keyword">catch</span> err
0232   <span class="keyword">if</span> verbose_flag
0233     fprintf(<span class="string">'deleting temporary lock file for this process: %s\n'</span>,lock_file);
0234   <span class="keyword">end</span>
0235   delete(lock_file);
0236   delete(common_lock_file);
0237   <a href="displayError.html" class="code" title="function displayError(err)">displayError</a>(err);
0238 <span class="keyword">end</span>  
0239 
0240 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0241 <span class="comment">%% SUBFUNCTIONS</span>
0242 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0243 <a name="_sub1" href="#_subfunctions" class="code">function id=NextStudyinfoID(study_dir,OS)</a>
0244 <span class="comment">% purpose: determine the max existing lock id with min timestamp</span>
0245 <span class="comment">% i.e., get the max sim_id for all processes waiting to write to/read from</span>
0246 <span class="comment">% studyinfo.mat, as determined by the existence of .?lock_* files.</span>
0247 <span class="comment">% lock_file format: .lock_&lt;timestamp&gt;_&lt;id&gt; or lock_&lt;timestamp&gt;_&lt;id&gt;</span>
0248 id=0; <span class="comment">% next process id</span>
0249 <span class="keyword">switch</span> OS
0250   <span class="keyword">case</span> {<span class="string">'linux'</span>,<span class="string">'darwin'</span>} <span class="comment">% Linux or Mac</span>
0251     <span class="comment">% check if there are any lock files</span>
0252     [status,result]=system([<span class="string">'ls '</span> fullfile(study_dir,<span class="string">'.lock_*'</span>)]);
0253     <span class="keyword">if</span> status==0 <span class="comment">% there exist lock files</span>
0254       <span class="comment">% get list of locked ids</span>
0255       ids=regexp(result,<span class="string">'.lock_\d+_(\d+)'</span>,<span class="string">'tokens'</span>);
0256       <span class="keyword">if</span> ~isempty(ids)
0257         <span class="comment">% identify the max id</span>
0258         ids=[ids{:}];
0259         id=max(cell2num(ids));
0260       <span class="keyword">end</span>
0261 <span class="comment">%       % get list of timestamps in lock file names</span>
0262 <span class="comment">%       timestamps=regexp(result,'.lock_(\d+)_\d+','tokens');</span>
0263 <span class="comment">%       if ~isempty(timestamps)</span>
0264 <span class="comment">%         % identify the next timestamp to process</span>
0265 <span class="comment">%         timestamps=[timestamps{:}];</span>
0266 <span class="comment">%         x=cell2num(timestamps);</span>
0267 <span class="comment">%         timestamp=timestamps{x==min(x)};</span>
0268 <span class="comment">%         % get list of locked ids with that timestamp</span>
0269 <span class="comment">%         ids=regexp(result,sprintf('.lock_%s_(\\d+)',timestamp),'tokens');</span>
0270 <span class="comment">%         % get max id from lock with min timestamp</span>
0271 <span class="comment">%         id=max(cell2num([ids{:}]));</span>
0272 <span class="comment">%       end</span>
0273     <span class="keyword">end</span>
0274   <span class="keyword">otherwise</span> <span class="comment">% Windows</span>
0275     D=dir(study_dir);
0276     status=~any(find(~cellfun(@isempty,regexp({D.name},<span class="string">'^lock_'</span>))));
0277     <span class="keyword">if</span> status==0 <span class="comment">% there exist lock files</span>
0278       <span class="comment">% get list of timestamps in lock file names</span>
0279       timestamps=regexp({D.name},<span class="string">'lock_(\d+)_\d+'</span>,<span class="string">'tokens'</span>,<span class="string">'once'</span>);
0280       <span class="keyword">if</span> ~isempty(timestamps)
0281         <span class="comment">% identify the next timestamp to process</span>
0282         timestamps=[timestamps{:}];
0283         <span class="keyword">if</span> isempty(timestamps), <span class="keyword">return</span>; <span class="keyword">end</span>
0284         x=cell2num(timestamps);
0285         timestamp=timestamps{x==min(x)};
0286         <span class="comment">% get list of locked ids with that timestamp</span>
0287         ids=regexp({D.name},sprintf(<span class="string">'lock_%s_(\\d+)'</span>,timestamp),<span class="string">'tokens'</span>,<span class="string">'once'</span>);
0288         <span class="comment">% get max id from lock with min timestamp</span>
0289         id=max(cell2num([ids{:}]));
0290       <span class="keyword">end</span>
0291     <span class="keyword">end</span>
0292 <span class="keyword">end</span>
0293 
0294 <span class="comment">%% wait until there are no lock files from other processes (or timeout)</span>
0295 <span class="comment">% NOTE: no longer necessary since adding timestamp to lock file name...</span>
0296 <span class="comment">% todo: remove this section after extensive testing (do under version</span>
0297 <span class="comment">% control so that the code remains on record)</span>
0298 <span class="comment">%{</span>
0299 timeout=30*5; <span class="comment">% seconds</span>
0300 delay=0.01; <span class="comment">% seconds</span>
0301 <span class="keyword">for</span> idx=1:(5*timeout/delay) <span class="comment">% timeout after 5*timeout sec (then clear all lock files if timed out)</span>
0302     <span class="comment">% note: time-out at this step should be longer than below to allow for</span>
0303     <span class="comment">% removal of stale lock files by other processes currently attempting access.</span>
0304   <span class="comment">% check if there exist any files named .lock_*</span>
0305   <span class="comment">% --------------------------------------------</span>
0306   <span class="keyword">switch</span> OS
0307     <span class="keyword">case</span> {<span class="string">'linux'</span>,<span class="string">'darwin'</span>} <span class="comment">% Linux or Mac</span>
0308       <span class="comment">% lock_file format: .lock_&lt;timestamp&gt;_&lt;id&gt;</span>
0309       [status,~]=system([<span class="string">'ls '</span> study_dir <span class="string">'/.lock_*'</span>]); <span class="comment">% note: ls is faster than dir</span>
0310     <span class="keyword">otherwise</span> <span class="comment">% Windows</span>
0311       <span class="comment">% lock_file format: lock_&lt;timestamp&gt;_&lt;id&gt;</span>
0312       D=dir(study_dir);
0313       status=~any(find(~cellfun(@isempty,regexp({D.name},<span class="string">'^lock_'</span>))));
0314   <span class="keyword">end</span>
0315   <span class="comment">% --------------------------------------------</span>
0316   <span class="keyword">if</span> status==0 <span class="comment">% there exists a file .lock_*</span>
0317     <span class="comment">% note: {.lock_*} are temporary files created to indicate periods during</span>
0318     <span class="comment">% which studyinfo.mat is being accessed. studyinfo.mat should not be</span>
0319     <span class="comment">% loaded until all .lock_* files have been removed.</span>
0320     pause(delay); <span class="comment">% wait</span>
0321   <span class="keyword">else</span>
0322     <span class="keyword">break</span>;
0323   <span class="keyword">end</span>
0324 <span class="keyword">end</span>
0325 <span class="comment">% if timed out: delete all lock files blocking this process</span>
0326 <span class="keyword">if</span> idx==(timeout/delay)
0327   <span class="keyword">if</span> verbose_flag
0328     fprintf(<span class="string">'deleting all temporary lock files blocking this process...\n'</span>);
0329   <span class="keyword">end</span>
0330   D=dir(study_dir); <span class="comment">% contents of study_dir directory</span>
0331   inds=find(~cellfun(@isempty,regexp({D.name},<span class="string">'^.?lock_'</span>)));
0332   <span class="comment">% delete all lock files</span>
0333   <span class="keyword">for</span> i=1:length(inds)
0334     file=fullfile(study_dir,D(inds(i)).name);
0335     <span class="keyword">if</span> verbose_flag
0336       fprintf(<span class="string">'\t%s\n'</span>,file);
0337     <span class="keyword">end</span>
0338     delete(file);
0339   <span class="keyword">end</span>
0340 <span class="keyword">end</span>
0341 <span class="comment">%}</span></pre></div>
<hr><address>Generated on Fri 07-Apr-2017 20:01:20 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>