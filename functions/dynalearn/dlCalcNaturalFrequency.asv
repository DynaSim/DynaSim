function [y, l] = dlCalcNaturalFrequency(dlObj, opts)

    dlPotentialIndices = endsWith(dlObj.dlVariables, '_V');
    dlPotentialIndices(1) = 1;
    dlPotentials = dlObj.dlOutputs(dlPotentialIndices);
    dlLabels = dlObj.dlVariables(dlPotentialIndices);

    n = size(dlPotentials, 2);
    y = zeros(n, 1);

    Fs = (1 / (dlObj.dldT*dlObj.dlDownSampleFactor)) * 1000;
    L = size(dlPotentials{1}, 1);
    % t = (0:L-1)*T;

    % dtf = ceil(1 / (dlObj.dldT*dlObj.dlDownSampleFactor));
    % 
    % lf1 = max(opts.lf1*dtf, 1);
    % hf1 = opts.hf1*dtf;
    
    figure("Position", [0 0 1500 1000]);
    for k = 1:n
        
        x = dlPotentials{1, k};
        x = mean(x, 2);
        x = detrend(x);

        Y = abs(fft(x)); 
        Y = Y(1:(L/2))
        yf1 = smooth(ffts(lf1:hf1));
        m = length(yf1);
        disp([lf1, hf1]);
        y(k) = ((find(yf1(1:floor(m/2)) == max(yf1(1:floor(m/2))), 1)) - 1);    

        subplot(k, 1, k);
        
        plot(yf1(1:floor(m/2)));
        title(dlLabels(k));
        xlabel(y(k));

    end
    
    l = dlLabels;

end

% Define the parameters for the sine wave
% Fs = 1000;            % Sampling frequency                    
% T = 1/Fs;             % Sampling period       
% L = 1500;             % Length of signal
        % Time vector

% Create a sine wave
% S = 0.7*sin(2*pi*50*t);

% Compute the FFT of the sine wave
Y = fft(S);

% Compute the two-sided spectrum P2. Then compute the single-sided spectrum P1 based on P2 and the even-valued signal length L.
P2 = abs(Y/L);
P1 = P2(1:L/2+1);
P1(2:end-1) = 2*P1(2:end-1);

% Define the frequency domain f and plot the single-sided amplitude spectrum P1. 
f = Fs*(0:(L/2))/L;
plot(f,P1) 
title('Single-Sided Amplitude Spectrum of S(t)')
xlabel('f (Hz)')
ylabel('|P1(f)|')